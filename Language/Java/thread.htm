<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=gb2312" />
	<script type="text/javascript" src="../../mylib/js/css.js"></script>
	<title>Java Note</title>
</head>

<body>
	<p id="title">多线程</p>
	<h1>First View</h1>
    <p>下例展示了一个最简单的线程使用示例，每隔一秒输出当前时间</p>
    <pre class="code" data-type="java">
import java.util.Date;

public class ThreadTest {

	public static void main(String[] args) {
		Thread thread = new Thread(new Runnable() {
			
			@Override
			public void run() {
				while (true) {
					try {
						Thread.sleep(1000);
						System.out.println(new Date().toString());
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			}
		});

		thread.start();
	}
}</pre>
    <h1>volatile</h1>
    <p>volatie 关键字主要用于如下场景：</p>
    <p>当多个线程访问同一个共享变量时，如果是多核 CPU，该共享变量可以会同时存放在多个内核的缓存中，因为 CPU 默认都是从缓存中读取数据，所以会存在数据更新不及时的问题。</p>
    <p>例如，核1修改了变量值，但不会立刻写回内存，核2访问变量时将仍会从核2的缓存中取到旧值。</p>
    <p>使用 volatile 关键字后，内核1修改变量值后，会立刻写回内存并通知其它内核的缓存失效。然后当核2取值时，会因缓存失效而重新从内存中读取该值。</p>
    <p>一个常用场景是线程的结束标志位实现，如下所示：</p>
    <pre class="code" data-type="java" data-collapsed="false" title="VolatileTest.java">
import java.time.LocalTime;

public class VolatileTest {
	
	private static class MyThread extends Thread {
		static volatile boolean keepRunning = true;
		
		@Override
		public void run() {
			while (keepRunning) {
				LocalTime time = LocalTime.now();
				System.out.println(getName() + " - " + time.toString());
				
				try {
					sleep(1000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}	
		}
		
		public void stopMe() {
			System.out.println("stop " + getName());
			keepRunning = false;
		}
	};
	
	public static void main(String[] args) throws InterruptedException {
		MyThread t1 = new MyThread();
		t1.setName("t1");
		MyThread t2 = new MyThread();
		t2.setName("t2");
		
		t1.start();
		t2.start();
		
		Thread.sleep(5000);
		
		//t2 is stopped too right
		t1.stopMe(); 

	}

}
</pre>
	<h1>synchronized 关键字</h1>
	<p>让我们看一下下面这段代码，让多个线程对同一个计数器累加并打印</p>
	<pre class="code" data-type="java">public class SimpleThreadTest {

    private static Integer testKey = 0;

    public static void main(String[] args) {
        Thread[] threads = new Thread[4];

        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread("Thread[" + i + "]") {
                @Override
                public void run() {
                    while (testKey < 500) {
                        System.out.println(super.getName() + " will set key as: " + (testKey + 1));
                        testKey += 1;
                        System.out.println(super.getName() + " set key as: " + testKey);
                    }
                };
            };
        }

        for (Thread thread : threads) {
            thread.start();
        }
    }
}
</pre>
	<p>运行结果可能如下所示：</p>
	<pre class="code" data-type="log">Thread[0] will set key as: 1
Thread[1] will set key as: 1
Thread[1] set key as: 1
Thread[0] set key as: 1
Thread[1] will set key as: 2
<span class="emphasis">Thread[0] will set key as: 2</span>
Thread[1] set key as: 2
Thread[1] will set key as: 4
Thread[1] set key as: 4
Thread[1] will set key as: 5
Thread[1] set key as: 5
Thread[1] will set key as: 6
Thread[1] set key as: 6
Thread[1] will set key as: 7
Thread[1] set key as: 7
Thread[1] will set key as: 8
Thread[1] set key as: 8
Thread[1] will set key as: 9
<span class="emphasis">Thread[0] set key as: 3</span>
</pre>
	<p>结果有点乱，注意一下 thread[0] 的打印记录，会看到不同线程并发访问时产生所潜在副作用。</p>
	<p>在如下代码中使用 synchronized 调整</p>
	<pre class="code" data-type="java">public class SimpleThreadTest {

    private static Integer testKey = 0;

    public static void main(String[] args) {
        Thread[] threads = new Thread[4];

        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread("Thread[" + i + "]") {
                @Override
                public void run() {
                    <span class="emphasis">synchronized (testKey) {</span>
                        while (testKey < 500) {
                            System.out.println(super.getName() + " will set key as: " + (testKey + 1));
                            testKey += 1;
                            System.out.println(super.getName() + " set key as: " + testKey);
                        }
                    }
                };
            };
        }

        for (Thread thread : threads) {
            thread.start();
        }
    }
}
</pre>
	<p>我们可以看到结果就很整齐了。</p>
	<h1>ThreadLocal</h1>
	<p>把上例的代码用 ThreadLocal 进行一下修改，如下所示</p>
	<pre class="code" data-type="java">public class ThreadLocalTest {

    private final static ThreadLocal&lt;Integer&gt; testKey = new ThreadLocal&lt;Integer&gt;() {
        @Override
        protected Integer initialValue() {
            return new Integer(0);
        };
    };

    public static void main(String[] args) {
        Thread[] threads = new Thread[4];

        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread("Thread[" + i + "]") {
                @Override
                public void run() {
                    while (testKey.get() < 500) {
                        System.out.println(super.getName() + " will set key as: " + (testKey.get() + 1));
                        testKey.set(testKey.get() + 1);
                        System.out.println(super.getName() + " set key as: " + testKey.get());
                    }
                };
            };
        }

        for (Thread thread : threads) {
            thread.start();
        }
    }
}
</pre>
	<p>我们可以看到不但线程间互相不受影响，而且每个线程独享一个计数器，其它线程的修改不影响当前线程的计数器。</p>
	<p>ThreadLocal 个般声明为 final static 类型</p>

    <h1>Callable &amp; Future</h1>	
    <p>Thread 和 Runnable 都不支持返回值，Java 5 引入了新的多线程接口 Callable 和 Future，可以获取线程执行后的返回结果。</p>
    <pre class="code" data-type="java" data-collapsed="false" title="CallableTest.java">
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableTest {
	final static Random random = new Random(System.currentTimeMillis());

	public static void main(String[] args) throws InterruptedException, ExecutionException {
		ExecutorService executor = Executors.newCachedThreadPool();

		Task task1 = new Task();
		Future&lt;Integer&gt; result1 = executor.submit(task1);
		Task task2 = new Task();
		Future&lt;Integer&gt; result2 = executor.submit(task2);

		// Don't accept new tasks
		executor.shutdown();

		System.out.println(&quot;main thread is working...&quot;);
		System.out.println(&quot;result 1: &quot; + result1.get());
		System.out.println(&quot;result 2: &quot; + result2.get());
		System.out.println(&quot;Done.&quot;);
	}

	private static class Task implements Callable&lt;Integer&gt; {
		@Override
		public Integer call() throws Exception {
			int waitingTime = 1000 + random.nextInt(1000);
			System.out.println(String.format(&quot;sub task will working %s ms.&quot;, waitingTime));
			Thread.sleep(waitingTime);
			return waitingTime;
		}
	}

}
</pre>
    <h1>生产者/消费者实现</h1>
    <h2>基于 Object.wait/notify</h2>
    <p>Object 类中定义了如下几个方法用于并发支持</p>
    <ul>
        <li>wait: 让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁）</li>
        <li>notify: 唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程</li>
        <li>notifyAll: 唤醒所有正在等待这个对象的monitor的线程</li>
    </ul>
    <p>实现如下</p>
    <pre class="code" data-type="java" data-collapsed="false" title="Basic Producer/Consumer">
package lld.test.thread;
import java.util.PriorityQueue;
import java.util.Random;
public class ProducerConsumerBasic {
	private final int MAX_SIZE = 10;
	private PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(MAX_SIZE);
	private final Random random = new Random(System.currentTimeMillis());
	public static void main(String[] args) {
		ProducerConsumerBasic obj = new ProducerConsumerBasic();
		Producer producer = obj.new Producer();
		Consumer consumer = obj.new Consumer();
		producer.start();
		consumer.start();
	}
	class Consumer extends Thread {
		@Override
		public void run() {
			consume();
		}
		private void consume() {
			while (true) {
				synchronized (queue) {
					if (queue.size() == 0) {
						System.out.println(&quot;Queue is empty!&quot;);
						try {
							queue.wait();
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
					Integer value = queue.poll();
					System.out.println(&quot;Consume &quot; + value);
					queue.notify();
					System.out.println(&quot;Queue left &quot; + queue.size());
				}
				try {
					Thread.sleep(random.nextInt(100));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}
	class Producer extends Thread {
		@Override
		public void run() {
			produce();
		}
		private void produce() {
			while (true) {
				synchronized (queue) {
					if (queue.size() == MAX_SIZE) {
						System.out.println(&quot;Queue is full!&quot;);
						try {
							queue.wait();
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}
					Integer value = random.nextInt(1000);
					queue.offer(value);
					System.out.println(&quot;Produce &quot; + value);
					queue.notify();
					System.out.println(&quot;Queue left &quot; + queue.size());
				}
				try {
					Thread.sleep(random.nextInt(100));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}
}
</pre>
    <h2>基于 Condition 实现</h2>
    <p>Condition 类是 Java 5 引用的用于线程间协作的新对象，用于取代传统的 Object 的 wait() 和 notify()。相比传统实现其更加安全和高效。</p>
    <ul>
        <li>await: 对应 Object.wait()</li>
        <li>signal: 对应 Object.notify()</li>
        <li>signalAll: 对应 Object.notifyAll()</li>
    </ul>
    <p>实现如下</p>
    <pre class="code" data-type="java" data-collapsed="false" title="Condition Producer/Consumer">
package lld.test.thread;

import java.util.PriorityQueue;
import java.util.Random;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ProducerConsumerCondition {

	private final int MAX_SIZE = 10;
	private PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(MAX_SIZE);
    private ReentrantLock lock=new ReentrantLock();
    private Condition notFull=lock.newCondition();
    private Condition notEmpty=lock.newCondition();
	private final Random random = new Random(System.currentTimeMillis());

	public static void main(String[] args) {
		ProducerConsumerCondition obj = new ProducerConsumerCondition();
		Producer producer = obj.new Producer();
		Consumer consumer = obj.new Consumer();
		producer.start();
		consumer.start();
	}

	class Consumer extends Thread {
		@Override
		public void run() {
			consume();
		}

		private void consume() {
			while (true) {
				lock.lock();
				
				try {
					if (queue.size() == 0) {
						System.out.println(&quot;Queue is empty!&quot;);

						try {
							notEmpty.await();
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}

					Integer value = queue.poll();
					System.out.println(&quot;Consume &quot; + value);
					notFull.signal();
					System.out.println(&quot;Queue left &quot; + queue.size());
				} finally {
					lock.unlock();
				}

				try {
					Thread.sleep(random.nextInt(100));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}

			}
		}
	}

	class Producer extends Thread {
		@Override
		public void run() {
			produce();
		}

		private void produce() {
			while (true) {
				lock.lock();
				
				try {
					if (queue.size() == MAX_SIZE) {
						System.out.println(&quot;Queue is full!&quot;);

						try {
							notFull.await();
						} catch (InterruptedException e) {
							e.printStackTrace();
						}
					}

					Integer value = random.nextInt(1000);
					queue.offer(value);
					System.out.println(&quot;Produce &quot; + value);
					notEmpty.signal();
					System.out.println(&quot;Queue left &quot; + queue.size());
				} finally {
					lock.unlock();
				}

				try {
					Thread.sleep(random.nextInt(100));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}

			}
		}
	}
}
</pre>
</body>
</html>
