<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head id="Head"><title>prototype.js　1.4版开发者手册(强烈推荐) - THIN-事繁勿慌，事闲勿荒，取象于钱，外圆内方 - 博客园</title>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta id="metaKeywords" name="keywords" content="prototype.js　1.4版开发者手册(强烈推荐) "><link id="MainCss" type="text/css" rel="stylesheet" href="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/style.css"><link id="SecondaryCss" type="text/css" rel="stylesheet" href="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/customcss.css"><link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/thinhunan/rss.aspx"><style>.reference table{border:1px dashed darkblue;} .reference th{border:1px dashed darkblue;color:white;background-color:darkblue;}  .reference td{border:1px dashed darkblue;corlor:black;background-color:white;} </style><style>
td { font-size: 12px }
.commentTextBox 
{ 
    font-family : Verdana; 
    font-size: 13px;
 }
 
a.blue:visited,
a.blue:active,
a.blue:link,
a.blue:hover
{
	color:blue;
	
}
</style><style>.userData { BEHAVIOR: url(#default#userdata) }
	</style><script src="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/recommend_v.js"></script><script src="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/getrecommend_v.htm"></script><meta name="vs_showGrid" content="False"><link href="" type="text/css" rel="stylesheet"></head><body>
    <form name="Form1" method="post" action="DeveloperNotesForPrototype.html" onsubmit="javascript:return WebForm_OnSubmit();" id="Form1">
<div>
<input name="__EVENTTARGET" id="__EVENTTARGET" value="" type="hidden">
<input name="__EVENTARGUMENT" id="__EVENTARGUMENT" value="" type="hidden">
<input name="__VIEWSTATE" id="__VIEWSTATE" value="" type="hidden">
</div>

<script type="text/javascript">
<!--
var theForm = document.forms['Form1'];
if (!theForm) {
    theForm = document.Form1;
}
function __doPostBack(eventTarget, eventArgument) {
    if (!theForm.onsubmit || (theForm.onsubmit() != false)) {
        theForm.__EVENTTARGET.value = eventTarget;
        theForm.__EVENTARGUMENT.value = eventArgument;
        theForm.submit();
    }
}
// -->
</script>


<script src="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/WebResource.js" type="text/javascript"></script>

<script language="JavaScript">
									function ctlent(evt,id)
											{
												if(evt.ctrlKey && evt.keyCode == 13)
												{	
													try
													{
														TempSave(id);
													}
													catch(ex)
													{
													}
													finally
													{
													    __doPostBack('AjaxHolder$PostComment$btnSubmit','')
													}
												}
		
												}</script>
												<script language="JavaScript">function SetReplyAuhor(author){document.getElementById('AjaxHolder_PostComment_tbComment').value+="@"+author+"\n";document.getElementById('AjaxHolder_PostComment_tbComment').focus();return false}</script>
<script src="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/ScriptResource.js" type="text/javascript"></script>
<script src="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/ScriptResource_003.js" type="text/javascript"></script>
<script src="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/ScriptResource_002.js" type="text/javascript"></script>
<script src="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/js.js" type="text/javascript"></script>
<script type="text/javascript">
<!--
function WebForm_OnSubmit() {
if (typeof(ValidatorOnSubmit) == "function" && ValidatorOnSubmit() == false) return false;
return true;
}
// -->
</script>

        
<table class="Framework" cellpadding="0" cellspacing="0" width="100%">
	<tbody><tr>
		<td>
			
<div id="top">
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/thinhunan/">THIN-事繁勿慌，事闲勿荒，取象于钱，外圆内方</a></h1>
<div id="subtitle">为赋新词强说愁
<script src="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-3285591-1";
urchinTracker();
</script>
</div>
</div>
<div id="sub">
<div class="BlogStats">随笔 - 231, 文章 - 3, 评论 - 2929, 引用 - 54</div>
</div>


</td>
	</tr>
</tbody></table>
<table class="Framework" cellpadding="0" cellspacing="0" width="100%">
	<tbody><tr>
		
		<td class="MainCell">
		  <div id="main">
				
					<script type="text/javascript">
//<![CDATA[
Sys.WebForms.PageRequestManager._initialize('AjaxHolder$scriptmanager1', document.getElementById('Form1'));
Sys.WebForms.PageRequestManager.getInstance()._updateControls(['tAjaxHolder$UpdatePanel1'], [], [], 90);
//]]>
</script>

	<div class="post">
		<h2>
			<a id="AjaxHolder_ctl01_TitleUrl" href="http://www.cnblogs.com/thinhunan/archive/2006/04/01/DeveloperNotesForPrototype.html">prototype.js　1.4版开发者手册(强烈推荐) </a>
		</h2>
		<div class="postbody">
		
   <script>   function sp(link)
   {
    var em =  'serg' + 'io_p' + 'ereira&#64;';
    em += 'ms' + 'n.c' + 'om';
    document.write('<a href="mai' + 'lto:' + em + '">' + link + '</a>');
   }
   function navigateToVersion(list)
   {
    var url = list.options[list.selectedIndex].value;
    if(url != '')
     document.location = url;
   }
  </script><div id="mainContent">
<h1><a href="http://prototype.conio.net/">prototype.js</a>开发者手册 </h1>
<h2>对应版本1.4.0 </h2>
<div>original article by sp('Sergio Pereira') <a href="mailto:sergio_pereira@msn.com">Sergio Pereira</a></div>
<div>
<p>last update: March 30th 2006</p>
<p>中文版：<a href="mailto:thin37421@126.com">THIN</a></p>
<p>最后更新：2006-3-31</p>
</div>
<!--                     Translators: check out the file prot-changeLogs.html in this same directory                    for the diff files.                    -->
<p id="versions"><select id="otherVersions" onchange="navigateToVersion(this)" name="select">
<option value="" selected="selected">其它版本</option>
<option value="http://www.sergiopereira.com/articles/prototype.js.html">English version</option>
<option value="DeveloperNotes-Prototype-JS.pdf">PDF (v1.4.0)</option>
<option value="http://openframework.or.kr/framework_reference/prototype_js/1.4.0/prototype.js.html">Korean (v1.4.0)</option>
<option value="http://www.fabryprog.it/from_sergiopereira/prototype.js.html">Italian (v1.4.0)</option>
<option value="prototype140.js.ptBR.html">Portuguese (v1.4.0)</option>
<option value="http://prototype.rajmi.hu/prototype.js.hu.html">Hungarian (v1.4.0)</option>
<option value="http://www.bouwkamp.com/ajax/prototype.js.html">Dutch (v1.4.0)</option>
<option value="http://blog.elksoft.pl/wp-content/prototype.js.pl.html">Polish (v1.4.0)</option>
<option value="http://www.imgsrc.co.jp/~kuriyama/prototype/prototype.js.html">Japanese (v1.4.0)</option>
<option value="prototype131.js.html">English (v1.3.1)</option>
<option value="https://compdoc2cn.dev.java.net/prototype/html/prototype.js.cn.html">Chinese (v1.3.1)</option>
<option value="http://victoryoalli.railsplayground.com/prototype.js.html">Spanish (v1.3.1)</option>
<option value="http://www.electrolinux.com/traductions/prototype.js.html">French (v1.3.1)</option>
<option value="http://www.devshare.de/_ajax/prototype.js.html">German (v1.3.1)</option>
<option value="prototype.js.ro.html">Romanian (v1.3.1)</option>
<option value="http://kropp.spb.ru/docs/prototype">Russian (v1.3.1)</option>
<option value="">Other versions (volunteers needed)</option>
</select> </p>
<p><span style="font-size: 10pt; color: rgb(0, 128, 0);">看到一个很好的东西在国内没有被很多人使用起来，实在是不爽，所以花了很大功夫把这个手册翻译成中文，<span style="color: red;">由于这篇文章很长，所以，翻译的工作量很大而且有些地方英文版也没有说清楚，虽得查看源代码，好在不是坚持做完了，大家鼓励下啊！^</span>o^<br>prototype.js是一个非常优雅的javascript基础类库，对javascript做了大量的扩展，而且很好的支持Ajax，国外有多个基于此类库实现的效果库，也做得很棒。<br>prototype.js不仅是一个有很大实用价值的js库，而且有很高的学习价值，所以我强烈建议B/S开发人员和对JS开发感兴趣的朋友去浏览一些它的源代码，其中有很多的珠玑，你绝对会觉得读它的源代码是一种享受，当然要读得懂，呵呵。<br>网上也有人写过1.3版的源码解读，大家可以找来看看。不过1.4版做了很大的扩充，所以希望有朋友写出1.4版的源码解读。</span><br><span style="color: red;">几点说明：
<ul>
    <li>有朋友说prototye已经有人翻译过了，呵呵，是对的，说明你以前关注过它，不过原来翻译的是1.3版的文档，1.4版有很多重要的扩展，而且pre_1.5版现在也出来，不地改动不大。
    </li><li>有朋友说有用多没有翻译地来的，拜托，只是各个方法的参数说明没有翻，这些说明很多都是什么类型，还是有空再弄吧，先将就一下，对不起了，翻到这个程序已经很累人了，毕竟有这么长。
    </li><li>做成CHM文档的事也只能Sorry，因为我没有这个时间，也没有做过CHM，我觉得排版一下看网页和CHM是差不多吧。 </li>
</ul>
</span>
</p><p>&nbsp;</p>
<h3>prototype.js是什么?</h3>
<p>万一你没有使用过大名鼎鼎的prototype.js，那么让我来告诉你，<a href="http://prototype.conio.net/">prototype.js</a>是由<a href="http://www.conio.net/">Sam Stephenson</a>写的一个javascript类库。这个构思奇妙，而且兼容标准的类库，能帮助你轻松建立有高度互动的web2.0特性的富客户端页面。</p>
<p>如果你最近尝试使用它，你大概了解到文档并不是作者的一个强项。和在我以前使用这个类库的不少开发者一样，一开始，我不得不一头扎进阅读prototype.js的源代码和实验它的功能中。我想，在我学习完它之后，把我学到的东西分享给大家是件不错的事。 </p>
<p>同时，在本文中，我也将提供一个关于这个类库提供的objects,classes,functions,extensions这对东东的<a href="#Reference">非官方参考</a></p>
<p>在阅读这个文档时，熟悉Ruby的开发者将会注意到Ruby的一些内建类和本类库扩展实现之间非常相似。 </p>
<h3>相关文章</h3>
<p>Advanced <a href="http://www.sergiopereira.com/articles/advjs.html">JavaScript guide</a>. </p>
<!-- ************************************************************************************************************************************* -->
<h3>一些实用的函数</h3>
<p>这个类库带有很多预定义的对象和实用函数，这些东东的目的显然是把你从一些重复的打字中解放出来 。 </p>
<!-- ------------------------------------------------------------------------------------------- -->
<h4>使用$()方法</h4>
<p>$() 方法是在DOM中使用过于频繁的 document.getElementById() 方法的一个便利的简写，就像这个DOM方法一样，这个方法返回参数传入的id的那个元素。</p>
<p>比起DOM中的方法，这个更胜一筹。你可以传入多个id作为参数然后 $() 返回一个带有所有要求的元素的一个 Array 对象。</p>
<pre class="programlisting">&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt; Test Page &lt;/TITLE&gt;
&lt;script src="prototype-1.3.1.js"&gt;&lt;/script&gt;
&lt;script&gt;
function test1()
{
var d = $('myDiv');
alert(d.innerHTML);
}
function test2()
{
var divs = $('myDiv','myOtherDiv');
for(i=0; i&lt;divs.length; i++)
{
alert(divs[i].innerHTML);
}
}
&lt;/script&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;div id="myDiv"&gt;
&lt;p&gt;This is a paragraph&lt;/p&gt;
&lt;/div&gt;
&lt;div id="myOtherDiv"&gt;
&lt;p&gt;This is another paragraph&lt;/p&gt;
&lt;/div&gt;
&lt;input type="button" value=Test1 onclick="test1();"&gt;&lt;br&gt;
&lt;input type="button" value=Test2 onclick="test2();"&gt;&lt;br&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;</pre>
<p>另外一个好处是，这个函数能传入用string表示的对象ID，也可以传入对象本身，这样，在建立其它能传两种类型的参数的函数时非常有用。</p>
<!-- ------------------------------------------------------------------------------------------- -->
<h4>使用$F()函数</h4>
<p>$F()函数是另一个大收欢迎的“快捷键”，它能用于返回任何表单输入控件的值，比如text box,drop-down list。这个方法也能用元素id或元素本身做为参数。 </p>
<pre class="code">&lt;script&gt;
function test3()
{
alert(  <span class="highlite">$F('userName')</span>  );
}
&lt;/script&gt;
&lt;input type="text" id="userName" value="Joe Doe"&gt;&lt;br&gt;
&lt;input type="button" value=Test3 onclick="test3();"&gt;&lt;br&gt;
<!-- ------------------------------------------------------------------------------------------- --></pre>
<h4>使用<span class="functionName">$A()</span>函数</h4>
<p>$A()函数能把它接收到的单个的参数转换成一个Array对象。</p>
<p>这个方法，结合被本类库扩展了的Array类，能方便的把任何的可枚举列表转换成或拷贝到一个Array对象。一个推荐的用法就是把DOM Node Lists转换成一个普通的Array对象，从而更有效率的进行遍历，请看下面的例子。</p>
<pre class="code">&lt;script&gt;
function showOptions(){
var someNodeList = $('lstEmployees').getElementsByTagName('option');
var nodes = $A(someNodeList);
nodes.each(function(node){
alert(node.nodeName + ': ' + node.innerHTML);
});
}
&lt;/script&gt;
&lt;select id="lstEmployees" size="10" &gt;
&lt;option value="5"&gt;Buchanan, Steven&lt;/option&gt;
&lt;option value="8"&gt;Callahan, Laura&lt;/option&gt;
&lt;option value="1"&gt;Davolio, Nancy&lt;/option&gt;
&lt;/select&gt;
&lt;input type="button" value="Show the options" onclick="showOptions();" &gt;
</pre>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>使用&nbsp;<span class="functionName">$H()</span> 函数</h4>
<p>$H()函数把一些对象转换成一个可枚举的和联合数组类似的Hash对象。</p>
<pre class="code">&lt;script&gt;
function testHash()
{
//let's create the object
var a = {
first: 10,
second: 20,
third: 30
};
//now transform it into a hash
var h = <span class="highlite">$H(a)</span>;
alert(h.toQueryString()); //displays: first=10&amp;second=20&amp;third=30
}
&lt;/script&gt;
</pre>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>使用<span class="functionName">$R()</span>函数</h4>
<p>$R()是new ObjectRange(lowBound,upperBound,excludeBounds)的缩写。</p>
<p>跳到<a href="#Reference.ObjectRange">ObjectRange</a> 类文档可以看到一个关于此类的完整描述. 此时，我们还是先来看一个例子以展示这个缩写能代替哪些方法吧。其它相关的一些知识可以在<a href="#Reference.Enumerable">Enumerable</a> 对象文档中找到。</p>
<pre class="code">&lt;script&gt;
function demoDollar_R(){
var range = <span class="highlite">$R(10, 20, false)</span>;
range.each(function(value, index){
alert(value);
});
}
&lt;/script&gt;
&lt;input type="button" value="Sample Count" onclick="demoDollar_R();" &gt;
</pre>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>使用<span class="functionName">Try.these()</span>函数</h4>
<p><tt class="literal">Try.these()</tt> 方法使得实现当你想调用不同的方法直到其中的一个成功正常的这种需求变得非常容易， 他把一系列的方法作为参数并且按顺序的一个一个的执行这些方法直到其中的一个成功执行，返回成功执行的那个方法的返回值。</p>
<p>在下面的例子中， <tt class="literal">xmlNode.text</tt>在一些浏览器中好用，但是<tt class="literal">xmlNode.textContent</tt>在另一些浏览器中正常工作。 使用<tt class="literal">Try.these()</tt>方法我们可以得到正常工作的那个方法的返回值。</p>
<p>&lt;script&gt;<br>function getXmlNodeValue(xmlNode){<br>&nbsp;&nbsp;&nbsp; return Try.these(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function() {return xmlNode.text;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; function() {return xmlNode.textContent;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>}<br>&lt;/script&gt;<br>&nbsp;&nbsp; </p>
<p><!-- ************************************************************************************************************************************* --></p>
<h3><span class="objectClass">Ajax</span>对象</h3>
<p>上面提到的共通方法非常好，但是面对它吧，它们不是最高级的那类东西。它们是吗？你很可能自己编写了这些甚至在你的脚本里面有类似功能的方法。但是这些方法只是冰山一角。</p>
<p>我很肯定你对prototype.js感兴趣的原因很可能是由于它的AJAX能力。所以让我们解释当你需要完成AJAX逻辑的时候，这个包如何让它更容易。</p>
<p><tt class="literal">Ajax</tt> 对象是一个预定义对象，由这个包创建，为了封装和简化编写<a href="http://en.wikipedia.org/wiki/Ajax_%28programming%29" target="_top">AJAX</a> 功能涉及的狡猾的代码。 这个对象包含一系列的封装AJAX逻辑的类。我们来看看其中几个类。<!-- ------------------------------------------------------------------------------------------- -->
</p><h4>使用<span class="objectClass">Ajax.Request</span>类</h4>
<p>如果你不使用任何的帮助程序包，你很可能编写了整个大量的代码来创建<tt class="literal">XMLHttpRequest</tt>对象并且异步的跟踪它的进程， 然后解析出响应 然后处理它。当你不需要支持多于一种类型的浏览器时你会感到非常的幸运。</p>
<p>为了支持 AJAX 功能。这个包定义了 <tt class="literal">Ajax.Request </tt>类。</p>
<p>假如你有一个应用程序可以通过url <span class="emphasis"><em>http://yoursever/app/get_sales?empID=1234&amp;year=1998</em></span>与服务器通信。它返回下面这样的XML 响应。</p>
<pre class="code">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ajax-response&gt;
&lt;response type="object" id="productDetails"&gt;
&lt;monthly-sales&gt;
&lt;employee-sales&gt;
&lt;employee-id&gt;1234&lt;/employee-id&gt;
&lt;year-month&gt;1998-01&lt;/year-month&gt;
&lt;sales&gt;$8,115.36&lt;/sales&gt;
&lt;/employee-sales&gt;
&lt;employee-sales&gt;
&lt;employee-id&gt;1234&lt;/employee-id&gt;
&lt;year-month&gt;1998-02&lt;/year-month&gt;
&lt;sales&gt;$11,147.51&lt;/sales&gt;
&lt;/employee-sales&gt;
&lt;/monthly-sales&gt;
&lt;/response&gt;
&lt;/ajax-response&gt;
</pre>
<p>用 <tt class="literal">Ajax.Request</tt>对象和服务器通信并且得到这段XML是非常简单的。下面的例子演示了它是如何完成的。</p>
<pre class="code">&lt;script&gt;
function searchSales()
{
var empID = $F('lstEmployees');
var y = $F('lstYears');
var url = 'http://yoursever/app/get_sales';
var pars = 'empID=' + empID + '&amp;year=' + y;
<div class="highlite">
var myAjax = new Ajax.Request(
url,
{
method: 'get',
parameters: pars,
onComplete: showResponse
});
</div>
}
function showResponse(originalRequest)
{
//put returned XML in the textarea
$('result').value = originalRequest.responseText;
}
&lt;/script&gt;
&lt;select id="lstEmployees" size="10" onchange="searchSales()"&gt;
&lt;option value="5"&gt;Buchanan, Steven&lt;/option&gt;
&lt;option value="8"&gt;Callahan, Laura&lt;/option&gt;
&lt;option value="1"&gt;Davolio, Nancy&lt;/option&gt;
&lt;/select&gt;
&lt;select id="lstYears" size="3" onchange="searchSales()"&gt;
&lt;option selected="selected" value="1996"&gt;1996&lt;/option&gt;
&lt;option value="1997"&gt;1997&lt;/option&gt;
&lt;option value="1998"&gt;1998&lt;/option&gt;
&lt;/select&gt;
&lt;br&gt;&lt;textarea id=result cols=60 rows=10 &gt;&lt;/textarea&gt;
</pre>
<p>你注意到传入 <tt class="literal">Ajax.Request</tt>构造方法的第二个对象了吗？ 参数<tt class="literal">{method: 'get', parameters: pars, onComplete: showResponse}</tt> 表示一个匿名对象的真实写法。他表示你传入的这个对象有一个名为 <tt class="literal">method</tt> 值为 <tt class="literal">'get'的属性，</tt>另一个属性名为 <tt class="literal">parameters</tt> 包含HTTP请求的查询字符串，和一个<tt class="literal">onComplete</tt> 属性/方法包含函数<tt class="literal">showResponse</tt>。 </p>
<p>还有一些其它的属性可以在这个对象里面定义和设置，如 <tt class="literal">asynchronous</tt>，可以为<tt class="literal">true</tt> 或 <tt class="literal">false</tt> 来决定AJAX对服务器的调用是否是异步的（默认值是 <tt class="literal">true</tt>）。</p>
<p>这个参数定义AJAX调用的选项。在我们的例子中，在第一个参数通过HTTP GET命令请求那个url，传入了变量 <tt class="literal">pars</tt>包含的查询字符串， <tt class="literal">Ajax.Request </tt>对象在它完成接收响应的时候将调用<tt class="literal">showResponse</tt> 方法。</p>
<p>也许你知道， <tt class="literal">XMLHttpRequest</tt>在HTTP请求期间将报告进度情况。这个进度被描述为四个不同阶段：<span class="emphasis"><em>Loading</em></span>, <span class="emphasis"><em>Loaded</em></span>, <span class="emphasis"><em>Interactive</em></span>, 或 <span class="emphasis"><em>Complete</em></span>。你可以使 <tt class="literal">Ajax.Request</tt> 对象在任何阶段调用自定义方法 ，<span class="emphasis"><em>Complete</em></span> 是最常用的一个。想调用自定义的方法只需要简单的在请求的选项参数中的名为 <tt class="literal">onXXXXX</tt> 属性/方法中提供自定义的方法对象。 就像我们例子中的 <tt class="literal">onComplete</tt> 。你传入的方法将会被用一个参数调用，这个参数是 <tt class="literal">XMLHttpRequest</tt> 对象自己。你将会用这个对象去得到返回的数据并且或许检查包含有在这次调用中的HTTP结果代码的 <tt class="literal">status</tt> 属性。</p>
<p>还有另外两个有用的选项用来处理结果。我们可以在<tt class="literal">onSuccess</tt> 选项处传入一个方法，当AJAX无误的执行完后调用， 相反的，也可以在<tt class="literal">onFailure</tt>选项处传入一个方法，当服务器端出现错误时调用。正如<tt class="literal">onXXXXX</tt> 选项传入的方法一样，这两个在被调用的时候也传入一个带有AJAX请求的<tt class="literal">XMLHttpRequest对象。</tt></p>
<p>我们的例子没有用任何有趣的方式处理这个 XML响应， 我们只是把这段XML放进了一个文本域里面。对这个响应的一个典型的应用很可能就是找到其中的想要的信息，然后更新页面中的某些元素， 或者甚至可能做某些XSLT转换而在页面中产生一些HTML。</p>
<p>&nbsp;在1.4.0版本中，一种新的事件回传外理被引入。如果你有一段代码总是要为一个特殊的事件执行，而不管是哪个AJAX调用引发它，那么你可以使用新的<a href="#Ajax.Responders">Ajax.Responders</a>对象。</p>
<p>假设你想要在一个AJAX调用正在运行时，显示一些提示效果，像一个不断转动的图标之类的，你可以使用两个全局事件Handler来做到，其中一个在第一个调用开始时显示图标，另一个在最后一个调用完成时隐藏图标。看下面的例子。</p>
<pre class="code">&lt;script&gt;
var myGlobalHandlers = {
onCreate: function(){
Element.show('systemWorking');
},
onComplete: function() {
if(Ajax.activeRequestCount == 0){
Element.hide('systemWorking');
}
}
};
<span class="highlite">Ajax.Responders.register(myGlobalHandlers);</span>
&lt;/script&gt;
&lt;div id='systemWorking'&gt;&lt;img src='spinner.gif'&gt;Loading...&lt;/div&gt;
</pre>
<p>更完全的解释，请参照 <a title="4.14.&nbsp;Ajax.Request 类" href="#ajax_request_reference">Ajax.Request 参考</a> 和 <a title="4.15.&nbsp;options 参数对象" href="#options_reference">Ajax选项参考</a>。</p>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>使用<span class="objectClass">Ajax.Updater</span>类</h4>
<p>如果你的服务器的另一端返回的信息已经是HTML了，那么使用这个程序包中 <tt class="literal">Ajax.Updater</tt> 类将使你的生活变得更加得容易。用它你只需提供哪一个元素需要被AJAX请求返回的HTML填充就可以了，例子比我写说明的更清楚。&nbsp;</p>
<pre class="code">&lt;script&gt;
function getHTML()
{
var url = 'http://yourserver/app/getSomeHTML';
var pars = 'someParameter=ABC';
<div class="highlite">
var myAjax = new Ajax.Updater(
'placeholder',
url,
{
method: 'get',
parameters: pars
});
</div>
}
&lt;/script&gt;
&lt;input type=button value=GetHtml onclick="getHTML()"&gt;
&lt;div id="placeholder"&gt;&lt;/div&gt;
</pre>
<p>你可以看到，这段代码比前面的例子更加简洁，不包括 <tt class="literal">onComplete</tt> 方法，但是在构造方法中传入了一个元素id。 我们来稍稍修改一下代码来描述如何在客户端处理服务器段错误成为可能。</p>
<p>我们将加入更多的选项， 指定处理错误的一个方法。这个是用 <tt class="literal">onFailure</tt> 选项来完成的。我们也指定了一个 <tt class="literal">placeholder</tt> 只有在成功请求之后才会被填充。为了完成这个目的我们修改了第一个参数从一个简单的元素id到一个带有两个属性的对象， <tt class="literal">success</tt> (一切OK的时候被用到) 和 <tt class="literal">failure</tt> (有地方出问题的时候被用到) 在下面的例子中没有用到<tt class="literal">failure</tt>属性，而仅仅在 <tt class="literal">onFailure</tt> 处使用了 <tt class="literal">reportError</tt> 方法。</p>
<p>&lt;script&gt;<br>function getHTML()<br>{<br>var url = 'http://yourserver/app/getSomeHTML';<br>var pars = 'someParameter=ABC';<br></p>
<pre class="code"><div class="highlite">
var myAjax = new Ajax.Updater(
{success: 'placeholder'},
url,
{
method: 'get',
parameters: pars,
onFailure: reportError
});
</div>
}
function reportError(request)
{
alert('Sorry. There was an error.');
}
&lt;/script&gt;
&lt;input type=button value=GetHtml onclick="getHTML()"&gt;
&lt;div id="placeholder"&gt;&lt;/div&gt;
</pre>
<p>如果你的服务器逻辑是连同HTML 标记返回JavaScript 代码， <tt class="literal">Ajax.Updater</tt>对象可以执行那段JavaScript代码。为了使这个对象对待响应为JavaScript，你只需在最后参数的对象构造方法中简单加入<tt class="literal">evalScripts: true</tt>属性。但是值得提醒的是，像这个选项名evalScripts暗示的，这些脚本会被执行，但是它们不会被加入到Page的脚本中。“有什么区别？”，可能你会这样问。我们假定请求地址返回的东东像这样：</p>
<pre class="code">&lt;script language="javascript" type="text/javascript"&gt;
function sayHi(){
alert('Hi');
}
&lt;/script&gt;
&lt;input type=button value="Click Me" onclick="sayHi()"&gt;
</pre>
<p>如果你以前这样尝试过，你知道这些脚本不会如你所期望的那样工作，原因是这段脚本会被执行，但像上面这样的脚本执行并不会创建一个名叫sayHi的函数，它什么也不做。如果要创建一个函数，我们应当把代码改成下面这个样子：</p>
<pre class="code">&lt;script language="javascript" type="text/javascript"&gt;
<div class="highlite">sayHi = function(){
alert('Hi');
};</div>
&lt;/script&gt;
&lt;input type=button value="Click Me" onclick="sayHi()"&gt;
</pre>
<p>为什么我们在上面的代码中不使用var关键字来声明这个变量呢（指sayHi&nbsp;），因为那样做创建出来的函数将只是当前脚本块的一个局部变量（至少在IE中是这样）。不写var关键字，创建出来的对象的作用域就是我们所期望的window。</p>
<p>更多相关知识，请参看&nbsp; <a href="#Ajax.Updater">Ajax.Updater reference</a> 和<a href="#Ajax.options">options reference</a>. </p>
<h3>枚举... 噢!噢!</h3>
<p>你知道，我们都是这样来做循环的，建一个Array，用elements组织它们，再建一个循环结构（例如for,foreach,while)通过index数字来访问每一个element，再用这个element做一些动作。 </p>
<p>当你想到这时，你会发现几乎每次写循环代码你都会迟早用到一个Array。那么，如果Array对象能够提供更多的功能给它们的迭代器使用不是很爽
吗？确实是这样，事实上很多的编程语言都在它们的Array或其它类似的结构中（如Collections,Lists）提供一些这样的功能。 </p>
<p>现在好了，prototype.js了给我们一个 <a class="code" href="#Reference.Enumerable">Enumerable</a>对象，它实现了很多和可迭代数据进行交互的窍门。和原有的JS对象相比prototype.js更上一层楼，它对<a href="#Reference.Array"><span class="code">Array</span> 类s</a>扩展了所有枚举要用的函数。 </p>
<h4>循环, Ruby样式的</h4>
<p>在标准的javascript中，如果你想把一个array中的所有elements显示出来，你可以像下面代码这样写得很好： </p>
<pre class="code">&lt;script&gt;
function showList(){
var simpsons = ['Homer', 'Marge', 'Lisa', 'Bart', 'Meg'];
<div class="highlite">            for(i=0;i&lt;simpsons.length;i++){
alert(simpsons[i]);
}</div>
}
&lt;/script&gt;
&lt;input type="button" value="Show List" onclick="showList();" &gt;
</pre>
<p>使用我们新的最好的朋友，prototype.js，我们可以把它生写成这样 </p>
<pre class="code">      function showList(){
var simpsons = ['Homer', 'Marge', 'Lisa', 'Bart', 'Meg'];
<div class="highlite">            simpsons.each( function(familyMember){
alert(familyMember);
});</div>
}
</pre>
<p>你可能会想“非常奇怪的方式...相对旧的，这种语法太怪异了”。哦，在上面的例子，确实什么也没有，在这个简单得要死例子中，也没有改变太多啊，尽管如此，请继续读下去。 </p>
<p>在继续下面内容之前，你注意到那个被做为一个参数传递给each函数的函数？我们把它理解成迭代器函数。 </p>
<h4>Your arrays on steroids</h4>
<p>就如我们上面提到的，把你的Array中的elements当成相同的类型使用相同的属性和函数是很通用(Common,不知该翻译成通用还是庸俗)的。让我们看看怎么样利用我们新的马力强劲的Arrays的迭代功能吧。 </p>
<p>依照标准找到一个element。
</p><p>
</p><pre class="code">&lt;script&gt;
function findEmployeeById(emp_id){
var listBox = $('lstEmployees')
var options = listBox.getElementsByTagName('option');
options = $A(options);
var opt = options.<span class="highlite">find</span>( <strong>function(employee){
return <span class="highlite">(employee.value == emp_id)</span>;
}</strong>);
alert(opt.innerHTML); //displays the employee name
}
&lt;/script&gt;
&lt;select id="lstEmployees" size="10" &gt;
&lt;option value="5"&gt;Buchanan, Steven&lt;/option&gt;
&lt;option value="8"&gt;Callahan, Laura&lt;/option&gt;
&lt;option value="1"&gt;Davolio, Nancy&lt;/option&gt;
&lt;/select&gt;
&lt;input type="button" value="Find Laura" onclick="findEmployeeById(8);" &gt;
</pre>
<p>现在我们再下一城，看看如何过滤一个Array中的元素，从每个元素中得到我们想要的成员。
</p><p>
</p><pre class="code">&lt;script&gt;
function showLocalLinks(paragraph){
paragraph = $(paragraph);
var links = $A(paragraph.getElementsByTagName('a'));
//find links that do not start with 'http'
var localLinks = links.<span class="highlite">findAll</span>( function(link){
var start = link.href.substring(0,4);
return start !='http';
});
//now the link texts
var texts = localLinks.<span class="highlite">pluck('innerHTML')</span>;
//get them in a single string
var result = texts.<span class="highlite">inspect()</span>;
alert(result);
}
&lt;/script&gt;
&lt;p id="someText"&gt;
This &lt;a href="http://othersite.com/page.html"&gt;text&lt;/a&gt; has
a &lt;a href="#localAnchor"&gt;lot&lt;/a&gt; of
&lt;a href="#otherAnchor"&gt;links&lt;/a&gt;. Some are
&lt;a href="http://wherever.com/page.html"&gt;external&lt;/a&gt;
and some are &lt;a href="#someAnchor"&gt;local&lt;/a&gt;
&lt;/p&gt;
&lt;input type=button value="Find Local Links" onclick="showLocalLinks('someText')"&gt;
</pre>
<p>上面的代码仅仅是一点小小的实践让人爱上这种语法。请参看 <a class="code" href="#Reference.Enumerable">Enumerable</a>和<a class="code" href="#Reference.Array">Array</a>的所有函数 </p>
<p><!-- ************************************************************************************************************************************* --></p>
<hr>
<p><a name="Reference"></a>&nbsp;</p>
<h3>prototype.js参考</h3>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>JavaScript类扩展</h4>
<p>prototype.js 类库实现强大功能的一种途径是扩展已有的JavaScript 类。 </p>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>对 <span class="code">Object的扩展</span></h4>
<p>
<table class="reference" id="Table1" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>extend(destination, source)</td>
            <td><nobr>static</nobr></td>
            <td>destination: any object, source: any object</td>
            <td class="refDescription">提供一种通过拷贝所有源以象属性和函数到目标函数实现继承的方法</td>
        </tr>
        <tr>
            <td>inspect(targetObj)</td>
            <td>static</td>
            <td>targetObj: any object</td>
            <td class="refDescription">返回可读性好关于目标对象的文字描述，如果对象实例没有定义一个inspect函数，默认返回toString函数的值。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4><span class="code">对Number的扩展</span></h4>
<p>
<table class="reference" id="Table2" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th><nobr>Kind</nobr></th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>toColorPart()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">返回数字的十六进制表示形式。在把一个RGB数字转换成HTML表现形式时很有用。</td>
        </tr>
        <tr>
            <td>succ()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">&nbsp;返回下一个数字，这个方法可用于迭代调用场景中。 </td>
        </tr>
        <tr>
            <td>times(iterator)</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(index)</td>
            <td class="refDescription">Calls the <span class="code">iterator</span> function repeatedly passing the current index in the <span class="code">index</span> argument. 反复调用iterator函数并传递当前index到iterator的index参数。 </td>
        </tr>
    </tbody>
</table>
</p>
<p>下面的例子用提示框显示0-9。 </p>
<pre class="code">&lt;script&gt;
function demoTimes(){
var n = 10;
n.times(function(index){
alert(index);
});
/***************************
* you could have also used:
*           (10).times( .... );
***************************/
}
&lt;/script&gt;
&lt;input type=button value="Test Number.times()" onclick="demoTimes()"&gt;
</pre>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>对 <span class="code">Function扩展</span></h4>
<p>
<table class="reference" id="Table3" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>bind(object)</td>
            <td><nobr>instance</nobr></td>
            <td>object: the object that owns the method</td>
            <td class="refDescription">返回function的实例，这个实例和源function的结构一样，但是它已被绑定给了参数中提供的object，就是说，function中的this指针指向参数object。</td>
        </tr>
        <tr>
            <td>bindAsEventListener(object)</td>
            <td>instance</td>
            <td>object: the object that owns the method</td>
            <td class="refDescription">用法和上面的bind一样，区别在于用来绑定事件。</td>
        </tr>
    </tbody>
</table>
</p>
<p>让我们看看如何运用这些扩展。 </p>
<pre class="code">&lt;input type=checkbox id=myChk value=1&gt; Test?
&lt;script&gt;
//declaring the class
var CheckboxWatcher = Class.create();
//defining the rest of the class implementation
CheckboxWatcher.prototype = {
initialize: function(chkBox, message) {
this.chkBox = $(chkBox);
this.message = message;
//assigning our method to the event
<div class="highlite">
this.chkBox.onclick =
this.showMessage.bindAsEventListener(this);
</div>
},
showMessage: function(evt) {
alert(this.message + ' (' + evt.type + ')');
}
};
var watcher = new CheckboxWatcher('myChk', 'Changed');
&lt;/script&gt;
</pre>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4><span class="code">对String的扩展</span></h4>
<p>
<table class="reference" id="Table4" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>stripTags()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">返回一个把所有的HTML或XML标记都移除的字符串。</td>
        </tr>
        <tr>
            <td>stripScripts()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">返回一个把所有的script都移除的字符串。</td>
        </tr>
        <tr>
            <td>escapeHTML()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">返回一个把所有的HTML标记合适的转义掉的字符串。</td>
        </tr>
        <tr>
            <td>unescapeHTML()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription"><span class="code">escapeHTML()的反转。</span></td>
        </tr>
        <tr>
            <td>extractScripts()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">返回一个包含在string中找到的所有&lt;script&gt;的数组。</td>
        </tr>
        <tr>
            <td>evalScripts()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">执行在string中找到的所有&lt;script&gt;。</td>
        </tr>
        <tr>
            <td>toQueryParams()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">把querystring分割才一个用parameter name做index的联合Array，更像一个hash。</td>
        </tr>
        <tr>
            <td>parseQuery()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription"><span class="code">和toQueryParams()一样</span>.</td>
        </tr>
        <tr>
            <td>toArray()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">把字符串转换成字符数组.</td>
        </tr>
        <tr>
            <td>camelize()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">转换一个以连字符连接的字符串成一个骆驼法样式的字符串。比如，这个函数在写代码时，把它做为一个样式工具使用是很有用的。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Reference.Array"></a></p>
<h4>对&nbsp; <span class="code">Array</span>的扩展</h4>
<p>因为array扩展于enumerable，所以所有enumberable对象的函数，array都是可以使用的，除此之外，下面的这些也是已经实现了的。 </p>
<p>
<table class="reference" id="Table5" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>clear()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">清空。</td>
        </tr>
        <tr>
            <td>compact()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">返回一个不包括源array中null或undefined元素的array,此方法不改变源array。</td>
        </tr>
        <tr>
            <td>first()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">返回array的第一个对象。</td>
        </tr>
        <tr>
            <td>flatten()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">通过递归组合array每个元素的子元素（如果该元素也是array)来返回一个“扁平的”一维的array。</td>
        </tr>
        <tr>
            <td>indexOf(value)</td>
            <td>instance</td>
            <td>value: what you are looking for.</td>
            <td class="refDescription">返回给出数字位置（从０算起）的元素，如果在该位置没有找到对象，返回-1。 </td>
        </tr>
        <tr>
            <td>inspect()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">重载inspect(),返回更好格式的反映Array每个元素的字符描述。</td>
        </tr>
        <tr>
            <td>last()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">返回最后一个元素。</td>
        </tr>
        <tr>
            <td>reverse([applyToSelf])</td>
            <td>instance</td>
            <td>applyToSelf: indicates if the array itself should also be reversed.</td>
            <td class="refDescription">&nbsp;反转Array中元素的顺序，如果没有给出参数，或参数为true，则源Array中元素的顺序也反转，否则源Array保持不变。 </td>
        </tr>
        <tr>
            <td>shift()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">返回Array的第一个元素并从Array中移除它，Array的Length-1。</td>
        </tr>
        <tr>
            <td>without(value1 [, value2 [, .. valueN]])</td>
            <td>instance</td>
            <td>value1 ... valueN: values to be excluded if present in the array.</td>
            <td class="refDescription">&nbsp;返回一个把参数列表中包含的元素从源Array中排除的Array。 </td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4><span class="code">document</span> DOM扩展</h4>
<p>
<table class="reference" id="Table6" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>getElementsByClassName(className [, parentElement])</td>
            <td><nobr>instance</nobr></td>
            <td>className:
name of a CSS class associated with the elements, parentElement: object
or id of the element that contains the elements being retrieved.</td>
            <td class="refDescription">返
回所有CSS className属性等于className参数的元素，如果没有给出parentElement,那么将搜索document
body。(此处使用document.body我觉得不如使用document,因为有时有的页面没有body)&nbsp; </td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4><span class="code">Event</span>扩展</h4>
<p>
<table class="reference" id="Table7" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>KEY_BACKSPACE</td>
            <td><nobr>Number</nobr>Number</td>
            <td class="refDescription">8: Constant. Code for the Backspace key.</td>
        </tr>
        <tr>
            <td>KEY_TAB</td>
            <td>Number</td>
            <td class="refDescription">9: Constant. Code for the Tab key.</td>
        </tr>
        <tr>
            <td>KEY_RETURN</td>
            <td>Number</td>
            <td class="refDescription">13: Constant. Code for the Return key.</td>
        </tr>
        <tr>
            <td>KEY_ESC</td>
            <td>Number</td>
            <td class="refDescription">27: Constant. Code for the Esc key.</td>
        </tr>
        <tr>
            <td>KEY_LEFT</td>
            <td>Number</td>
            <td class="refDescription">37: Constant. Code for the Left arrow key.</td>
        </tr>
        <tr>
            <td>KEY_UP</td>
            <td>Number</td>
            <td class="refDescription">38: Constant. Code for the Up arrow key.</td>
        </tr>
        <tr>
            <td>KEY_RIGHT</td>
            <td>Number</td>
            <td class="refDescription">39: Constant. Code for the Right arrow key.</td>
        </tr>
        <tr>
            <td>KEY_DOWN</td>
            <td>Number</td>
            <td class="refDescription">40: Constant. Code for the Down arrow key.</td>
        </tr>
        <tr>
            <td>KEY_DELETE</td>
            <td>Number</td>
            <td class="refDescription">46: Constant. Code for the Delete key.</td>
        </tr>
        <tr class="privateMember">
            <td>observers:</td>
            <td>Array</td>
            <td class="refDescription">List of cached observers. Part of the internal implementation details of the object.</td>
        </tr>
    </tbody>
</table>
</p>
<p>
<table class="reference" id="Table8" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>element(event)</td>
            <td>static</td>
            <td>event: an Event object</td>
            <td class="refDescription">返回事件源对象。</td>
        </tr>
        <tr>
            <td>isLeftClick(event)</td>
            <td>static</td>
            <td>event: an Event object</td>
            <td class="refDescription">如果点击了鼠标左键，返回true.</td>
        </tr>
        <tr>
            <td>pointerX(event)</td>
            <td>static</td>
            <td>event: an Event object</td>
            <td class="refDescription">返回鼠标的X座标。 </td>
        </tr>
        <tr>
            <td>pointerY(event)</td>
            <td>static</td>
            <td>event: an Event object</td>
            <td class="refDescription">返回鼠标的Y座标。</td>
        </tr>
        <tr>
            <td>stop(event)</td>
            <td>static</td>
            <td>event: an Event object</td>
            <td class="refDescription">使用此函数来中断事件的默认行为并阻止传递（冒泡)。</td>
        </tr>
        <tr>
            <td>findElement(event, tagName)</td>
            <td>static</td>
            <td>event: an Event object, tagName: name of the desired tag.</td>
            <td class="refDescription">从事件源对象开始向上搜索DOM树，直到找到第一个符合tagName的元素</td>
        </tr>
        <tr>
            <td>observe(element, name, observer, useCapture)</td>
            <td>static</td>
            <td>element: object or id, name: event name (like 'click', 'load', etc), observer: function to handle the event, useCapture: if <span class="code">true</span>, handles the event in the <em>capture</em> phase and if <span class="code">false</span> in the <em>bubbling</em> phase.</td>
            <td class="refDescription">为对象的某个事件增加一个处理函数。</td>
        </tr>
        <tr>
            <td>stopObserving(element, name, observer, useCapture)</td>
            <td>static</td>
            <td>element:
object or id, name: event name (like 'click'), observer: function that
is handling the event, useCapture: if true handles the event in the <em>capture</em> phase and if false in the <em>bubbling</em> phase.</td>
            <td class="refDescription">和上面的函数相反。</td>
        </tr>
        <tr class="privateMember">
            <td>_observeAndCache(element, name, observer, useCapture)</td>
            <td>static</td>
            <td>&nbsp;</td>
            <td class="refDescription">私有函数，别管它。</td>
        </tr>
        <tr class="privateMember">
            <td>unloadCache()</td>
            <td><nobr>static</nobr></td>
            <td>(none)</td>
            <td class="refDescription">私有函数，别管它。从内存中清除所有的observers缓存。</td>
        </tr>
    </tbody>
</table>
</p>
<p>下面代码演示如何给window添加一个load事件处理函数。 </p>
<pre class="code">&lt;script&gt;
<span class="highlite">Event.observe(window, 'load', showMessage, false);</span>
function showMessage() {
alert('Page loaded.');
}
&lt;/script&gt;
</pre>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>在prototype.js中定义新的对象和类</h4>
<p>另一个这个程序包帮助你的地方就是提供许多既支持面向对象设计理念又有共通功能的许多对象。 </p>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>The <span class="objectClass">PeriodicalExecuter</span> object</h4>
<p>这个对象提供一定间隔时间上重复调用一个方法的逻辑。 </p>
<p>
<table class="reference" id="Table9" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](callback, interval)</td>
            <td><nobr>constructor</nobr></td>
            <td>callback: a parameterless function, interval: number of seconds</td>
            <td class="refDescription">创建这个对象的实例将会重复调用给定的方法。</td>
        </tr>
    </tbody>
</table>
</p>
<p>
<table class="reference" id="Table10" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>callback</td>
            <td><nobr>Function()</nobr></td>
            <td class="refDescription">被调用的方法，该方法不能传入参数。</td>
        </tr>
        <tr>
            <td>frequency</td>
            <td>Number</td>
            <td class="refDescription">以秒为单位的间隔。</td>
        </tr>
        <tr class="privateMember">
            <td>currentlyExecuting</td>
            <td>Boolean</td>
            <td class="refDescription">表示这个方法是否正在执行。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>The <span class="objectClass">Prototype</span> object</h4>
<p><tt class="literal">Prototype</tt> 没有太重要的作用，只是声明了该程序包的版本 。 </p>
<p>
<table class="reference" id="Table11" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Version</td>
            <td>String</td>
            <td class="refDescription"><font face="宋体">版本。</font></td>
        </tr>
        <tr>
            <td>emptyFunction</td>
            <td><nobr>Function()</nobr></td>
            <td class="refDescription">空函数。</td>
        </tr>
        <tr>
            <td>K</td>
            <td>Function(obj)</td>
            <td class="refDescription">一个仅仅回传参数的函数。</td>
        </tr>
        <tr class="privateMember">
            <td>ScriptFragment</td>
            <td>String</td>
            <td class="refDescription">识别script的正则式。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Reference.Enumerable"></a></p>
<h4>The <span class="objectClass">Enumerable</span> object</h4>
<p>Enumberable对象能够已更优雅的方式实现对列表样式的结构进行枚举。 </p>
<p>很多其它的对象通过扩展自Enumberable对象来得到这些有用的接口。</p>
<p>
<table class="reference" id="Table12" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>each(iterator)</td>
            <td><nobr>instance</nobr></td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">把每个element做为第一个参数，element的index作为第一个参数调用iterator函数。</td>
        </tr>
        <tr>
            <td>all([iterator])</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">这
个函数会用给出的iterator测试整个集合，如果集合中任一元素在iterator函数测试中返回false或null，那么这个函数返回
false,否则返回true。如果没有给出iterator，那么就会测试所有的元素是不是不等于false和null。你可以简单的把它看成是“检测
每个元素都为非空非负”。 </td>
        </tr>
        <tr>
            <td>any(iterator)</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index), optional.</td>
            <td class="refDescription">这
个函数会用给出的iterator测试整个集合，如果集合中任一元素在iterator函数测试中返回true，那么这个函数返回true,否则返回
false。如果没有给出iterator，那么就会测试所有的元素是不是有一个不等于false和null。你可以简单的把它看成是“检测元素中是不是
有非空非负的”。 </td>
        </tr>
        <tr>
            <td>collect(iterator)</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">&nbsp;调用iterator函数根据集合中每个元素返回一个结果，然后按照原来集合中的顺序，返回一个Array。 </td>
        </tr>
        <tr>
            <td>detect(iterator)</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">集合中每个元素调用一次Iterator，返回第一个使Iterator返回True的元素，如果最终都没有为true的调用，那么返回null。 </td>
        </tr>
        <tr>
            <td>entries()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription"><span class="code">等于toArray()</span>. </td>
        </tr>
        <tr>
            <td>find(iterator)</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">等于 <span class="code">detect()</span>. </td>
        </tr>
        <tr>
            <td>findAll(iterator)</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">集合中每个元素调用Iterator，返回一个由所有调用Iterator返回结果等于true的元素组成的数组。和reject()相反。 </td>
        </tr>
        <tr>
            <td>grep(pattern [, iterator])</td>
            <td>instance</td>
            <td>pattern: a RegExp object used to match the elements, iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">&nbsp;用pattern参数正则表达式测试集合中的每个元素，返回一个包含所有匹配正则式的元素的Array，如果给出了Iterator，那个每个结果还要经过一下Iterator处理。 </td>
        </tr>
        <tr>
            <td>include(obj)</td>
            <td>instance</td>
            <td>obj: any object</td>
            <td class="refDescription">&nbsp;判断集合中包不包含指定对象。 </td>
        </tr>
        <tr>
            <td>inject(initialValue, iterator)</td>
            <td>instance</td>
            <td>initialValue:
any object to be used as the initial value, iterator: a function object
conforming to Function(accumulator, value, index)</td>
            <td class="refDescription">&nbsp;用Iterator联接所有集合中的元素。Iterator在被调用时把上一次迭代的结果做为第一个参数传给accumulator。第一次迭代时，accurmelator等于initialValue,最后返回accumulator的值。 </td>
        </tr>
        <tr>
            <td>invoke(methodName [, arg1 [, arg2 [...]]])</td>
            <td>instance</td>
            <td>methodName:
name of the method that will be called in each element, arg1..argN:
arguments that will be passed in the method invocation.</td>
            <td class="refDescription">集合中的每个元素调用指定的函数（查看源代码可以发现指定函数被调用时，this指针被传成当前元素），并传入给出的参数，返回调用结果组成的Array。 </td>
        </tr>
        <tr>
            <td>map(iterator)</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription"><span class="code">同collect()</span>. </td>
        </tr>
        <tr>
            <td>max([iterator])</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">返回集合中元素的最大值，或调用Iterator后返回值的最大值(如果给出了Iterator的话)。 </td>
        </tr>
        <tr>
            <td>member(obj)</td>
            <td>instance</td>
            <td>obj: any object</td>
            <td class="refDescription">同 <span class="code">include()</span>. </td>
        </tr>
        <tr>
            <td>min([iterator])</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">返回最小值，参见max()。 </td>
        </tr>
        <tr>
            <td>partition([iterator])</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">返回一个包含两个Array的Array，第一个Array包含所有调用Iterator返回True的元素，第二个Array包含剩下的元素。如果Iterator没有给出，那么就根据元素本身判断。 </td>
        </tr>
        <tr>
            <td>pluck(propertyName)</td>
            <td>instance</td>
            <td>propertyName name of the property that will be read from each element. This can also contain the index of the element</td>
            <td class="refDescription">返回每个元素的指定属性名的属性的值组成的Array。 </td>
        </tr>
        <tr>
            <td>reject(iterator)</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">和&nbsp; <span class="code">findAll()相反（返回所有等于false的元素）</span>. </td>
        </tr>
        <tr>
            <td>select(iterator)</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">同 <span class="code">findAll()</span>. </td>
        </tr>
        <tr>
            <td>sortBy(iterator)</td>
            <td>instance</td>
            <td>iterator: a function object conforming to Function(value, index)</td>
            <td class="refDescription">根据每个元素调用Iterator返回的值进行排序返回一个Array。 </td>
        </tr>
        <tr>
            <td>toArray()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">返回由集合所有元素组成的一个Array。 </td>
        </tr>
        <tr>
            <td>zip(collection1[, collection2 [, ... collectionN [,transform]]])</td>
            <td>instance</td>
            <td>collection1 .. collectionN: enumerations that will be merged, transform: a function object conforming to Function(value, index)</td>
            <td class="refDescription">合
并每个给出的集合到当前集合。合并操作返回一个新的array，这个array的元素个数和原集合的元素个数一样，这个array的每个元素又是一个子
array,它合并了所有集合中相同index的元素。如果transform函数被指定，那么array的每个元素还会调用transform函数先做
处理。举个例子: [1,2,3].zip([4,5,6], [7,8,9]).inspect()&nbsp;返回 "[
[1,4,7],[2,5,8],[3,6,9] ]" </td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Reference.Hash"></a></p>
<h4>The <span class="objectClass">Hash</span> object</h4>
<p>&nbsp;Hash对象实现一种Hash结构，也就是一个Key:Value对的集合。 </p>
<p>Hash中的每个Item是一个有两个元素的array，前一个是Key，后一个是Value，每个Item也有两个不需加以说明的属性,key和value。 </p>
<p>
<table class="reference" id="Table13" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>keys()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">返回所有Item的key的集合的一个array。 </td>
        </tr>
        <tr>
            <td>values()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">返回所有Item的value的集合的一个array。 </td>
        </tr>
        <tr>
            <td>merge(otherHash)</td>
            <td>instance</td>
            <td>otherHash: Hash object</td>
            <td class="refDescription">合并给出的Hash，返回一个新Hash。 </td>
        </tr>
        <tr>
            <td>toQueryString()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">以QueryString那样的样式返回hash中所有的item，例如： <span class="code">'key1=value1&amp;key2=value2&amp;key3=value3'</span> </td>
        </tr>
        <tr>
            <td>inspect()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">用一种合适的方法显示hash中的key:value对。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Reference.ObjectRange"></a></p>
<h4>The <span class="objectClass">ObjectRange</span> class</h4>
<p><em>继承自&nbsp; <a class="code" href="#Reference.Enumerable">Enumerable</a></em></p>
<p>用上、下边界描述一个对象区域。 </p>
<p>
<table class="reference" id="Table14" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Kind</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>start</td>
            <td>(any)</td>
            <td><nobr>instance</nobr></td>
            <td class="refDescription">
            <p>range的下边界</p>
            </td>
        </tr>
        <tr>
            <td>end</td>
            <td>(any)</td>
            <td>instance</td>
            <td class="refDescription">range的上边界</td>
        </tr>
        <tr>
            <td>exclusive</td>
            <td>Boolean</td>
            <td>instance</td>
            <td class="refDescription">决定边界自身是不是range的一部分。</td>
        </tr>
    </tbody>
</table>
</p>
<p>
<table class="reference" id="Table15" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](start, end, exclusive)</td>
            <td>constructor</td>
            <td>start: the lower bound, end: the upper bound, exclusive: include the bounds in the range?</td>
            <td class="refDescription">创建一个range对象，从start生成到end,这里要注意的是，start和end必段类型一致，而且该类型要有succ()方法。 </td>
        </tr>
        <tr>
            <td>include(searchedValue)</td>
            <td><nobr>instance</nobr></td>
            <td>searchedValue: value that we are looking for</td>
            <td class="refDescription">检查一个value是不是在range中。 </td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>The <span class="objectClass">Class</span> object</h4>
<p>在这个程序包中 <tt class="literal">Class</tt> 对象在声明其他的类时候被用到 。用这个对象声明类使得新类支持 <tt class="literal">initialize()</tt> 方法，他起构造方法的作用。</p>
<p>看下面的例子</p>
<p>//declaring the class<br><span class="highlite">var MySampleClass = Class.create();</span><br><br>//defining the rest of the class implmentation<br>MySampleClass.prototype = {<br><br>&nbsp;&nbsp; initialize: function(message) {<br>this.message = message;<br>&nbsp;&nbsp; },<br><br>&nbsp;&nbsp; showMessage: function(ajaxResponse) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(this.message);<br>&nbsp;&nbsp; }<br>}; <br><br>//now, let's instantiate and use one object<br>var myTalker = new MySampleClass('hi there.');<br>myTalker.showMessage(); //displays alert<br><br></p>
<p>
<table class="reference" id="Table16" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>create(*)</td>
            <td><nobr>instance</nobr></td>
            <td>(any)</td>
            <td class="refDescription">定义新类的构造方法。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --></p>
<h4>The <span class="objectClass">Ajax</span> object</h4>
<p>这个对象被用作其他提供AJAX功能的类的根对象。&nbsp;</p>
<p>
<table class="reference" id="Table17" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Kind</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>activeRequestCount</td>
            <td>Number</td>
            <td>instance</td>
            <td class="refDescription">正在处理中的Ajax请求的个数。</td>
        </tr>
    </tbody>
</table>
</p>
<p>
<table class="reference" id="Table18" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>getTransport()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">返回新的<tt class="literal">XMLHttpRequest</tt> 对象。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Ajax.Responders"></a></p>
<h4>The <span class="objectClass">Ajax.Responders</span> object</h4>
<p><em>继承自 <a class="code" href="#Reference.Enumerable">Enumerable</a></em></p>
<p>这个对象维持一个在Ajax相关事件发生时将被调用的对象的列表。比如，你要设置一个全局钩子来处理Ajax操作异常，那么你就可以使用这个对象。 </p>
<p>
<table class="reference" id="Table19" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Kind</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>responders</td>
            <td>Array</td>
            <td><nobr>instance</nobr></td>
            <td class="refDescription">被注册到Ajax事件通知的对象列表。</td>
        </tr>
    </tbody>
</table>
</p>
<p>
<table class="reference" id="Table20" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>register(responderToAdd)</td>
            <td>instance</td>
            <td>responderToAdd: object with methods that will be called.</td>
            <td class="refDescription">被传入参数的对象应包含名如Ajax事件的系列方法（如onCreate,onComplete,onException）。通讯事件引发所有被注册的对象的合适名称的函数被调用。 </td>
        </tr>
        <tr>
            <td>unregister(responderToRemove)</td>
            <td>instance</td>
            <td>responderToRemove: object to be removed from the list.</td>
            <td class="refDescription">&nbsp;从列表中移除。 </td>
        </tr>
        <tr>
            <td>dispatch(callback, request, transport, json)</td>
            <td>instance</td>
            <td>callback:
name of the AJAX event being reported, request: the Ajax.Request object
responsible for the event, transport: the XMLHttpRequest object that
carried (or is carrying) the AJAX call, json: the X-JSON header of the
response (if present) </td>
            <td class="refDescription">遍历被
注册的对象列表，找出有由callback参数决定的那个函数的对象。然后向这些函数传递其它的三个参数，如果Ajax响应中包含一个含有JSON内容的
X-JSON
HTTP头，那么它会被热行并传入json参数。如果事件是onException,那么transport参数会被异常代替，json不会传递。 </td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Ajax.Base"></a></p>
<h4>The <span class="objectClass">Ajax.Base</span> class</h4>
<p>这个类是其他在Ajax对象中定义的类的基类。 </p>
<p>
<table class="reference" id="Table21" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>setOptions(options)</td>
            <td><nobr>instance</nobr></td>
            <td>options: <a href="#Ajax.options">AJAX options</a></td>
            <td class="refDescription">设定AJAX操作想要的选项。</td>
        </tr>
        <tr>
            <td>responseIsSuccess()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">返回 <tt class="literal">true</tt> 如果AJAX操作成功,否则为 <tt class="literal">false</tt> 。</td>
        </tr>
        <tr>
            <td>responseIsFailure()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">与 <tt class="literal">responseIsSuccess()</tt> 相反。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Ajax.Request"></a></p>
<h4>The <span class="objectClass">Ajax.Request</span> class</h4>
<p><em>继承自 <a class="code" href="#Ajax.Base">Ajax.Base</a></em></p>
<p>封装 AJAX 操作 </p>
<p>
<table class="reference" id="Table22" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Kind</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Events</td>
            <td>Array</td>
            <td>static</td>
            <td class="refDescription">在AJAX操作中所有可能报告的事件/状态的列表。这个列表包括: <tt class="literal">'Uninitialized', 'Loading', 'Loaded', 'Interactive', </tt>和 <tt class="literal">'Complete'</tt>。</td>
        </tr>
        <tr>
            <td>transport</td>
            <td>XMLHttpRequest</td>
            <td>instance</td>
            <td class="refDescription">承载AJAX操作的 <tt class="literal">XMLHttpRequest</tt> 对象。</td>
        </tr>
        <tr>
            <td>url</td>
            <td><nobr>string</nobr></td>
            <td><nobr>instance</nobr></td>
            <td class="refDescription">请求的URL。</td>
        </tr>
    </tbody>
</table>
</p>
<p>
<table class="reference" id="Table23" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](url, options)</td>
            <td>constructor</td>
            <td>url: the url to be fetched, options: AJAX options</td>
            <td class="refDescription">创建这个对象的一个实例，它将在给定的选项下请求url。onCreate事件在调用constructor事被激发。 <span class="bold"><b>重要：</b></span> 如果选择的url受到浏览器的安全设置，他会一点作用也不起。 很多情况下，浏览器不会请求与当前页面不同主机(域名)的url。 你最好只使用本地url来避免限制用户配置他们的浏览器(谢谢Clay)</td>
        </tr>
        <tr class="privateMember">
            <td>evalJSON()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">这个方法显然不会被外部调用。它在Ajax响应中含有X-JSON&nbsp;HTTP头时用于内部调用执行这些内容。</td>
        </tr>
        <tr class="privateMember">
            <td>evalReponse()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">这也方法显然不会被外部调用，如果Ajax响应含有一个值为text/javascript的Cotent-Type头，那么这个方法就用被调用执行响应体。</td>
        </tr>
        <tr>
            <td>header(name)</td>
            <td>instance</td>
            <td>name: HTTP header name</td>
            <td class="refDescription">引用Ajax响应的头的内容，在Ajax访问结束后再调用这个方法。</td>
        </tr>
        <tr class="privateMember">
            <td>onStateChange()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">这个方法通常不会被外部调用。 当AJAX请求状态改变的时候被这个对象自己调用。</td>
        </tr>
        <tr class="privateMember">
            <td>request(url)</td>
            <td><nobr>instance</nobr></td>
            <td>url: url for the AJAX call</td>
            <td class="refDescription">这个方法通常不会被外部调用。已经在构造方法中调用了。</td>
        </tr>
        <tr class="privateMember">
            <td>respondToReadyState(readyState)</td>
            <td>instance</td>
            <td>readyState: state number (1 to 4)</td>
            <td class="refDescription">这个方法通常不会被外部调用。 当AJAX请求状态改变的时候被这个对象自己调用。</td>
        </tr>
        <tr class="privateMember">
            <td>setRequestHeaders()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">这个方法通常不会被外部调用。 被这个对象自己调用来配置在HTTP请求要发送的HTTP报头。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Ajax.options"></a></p>
<h4>The <span class="objectClass">options</span> argument object</h4>
<p>An important part of the AJAX operations is the <span class="code">options</span> argument. There's no <span class="code">options</span>
class per se. Any object can be passed, as long as it has the expected
properties. It is common to create anonymous objects just for the AJAX
calls. </p>
<p>
<table class="reference" id="Table24" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Default</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>method</td>
            <td>String</td>
            <td>'post'</td>
            <td class="refDescription">HTTP 请求方式。</td>
        </tr>
        <tr>
            <td>parameters</td>
            <td><nobr>String</nobr></td>
            <td>''</td>
            <td class="refDescription">在HTTP请求中传入的url格式的值列表。</td>
        </tr>
        <tr>
            <td>asynchronous</td>
            <td>Boolean</td>
            <td>true</td>
            <td class="refDescription">指定是否做异步 AJAX 请求。</td>
        </tr>
        <tr>
            <td>postBody</td>
            <td>String</td>
            <td>undefined</td>
            <td class="refDescription">在HTTP POST的情况下，传入请求体中的内容。</td>
        </tr>
        <tr>
            <td>requestHeaders</td>
            <td>Array</td>
            <td>undefined</td>
            <td class="refDescription">和请求一起被传入的HTTP头部列表， 这个列表必须含有偶数个项目， 任何奇数项目是自定义的头部的名称， 接下来的偶数项目使这个头部项目的字符串值。 例子:<tt class="literal">['my-header1', 'this is the value', 'my-other-header', 'another value']</tt> </td>
        </tr>
        <tr>
            <td>onXXXXXXXX</td>
            <td>Function(XMLHttpRequest, Object)</td>
            <td>undefined</td>
            <td class="refDescription">在AJAX请求中，当相应的事件/状态形成的时候调用的自定义方法。 例如 <tt class="literal">var myOpts = {onComplete: showResponse, onLoaded: registerLoaded};</tt>. 这个方法将被传入一个参数， 这个参数是承载AJAX操作的 <tt class="literal">XMLHttpRequest</tt> 对象，另一个是包含被执行X-JSON响应HTTP头。</td>
        </tr>
        <tr>
            <td>onSuccess</td>
            <td>Function(XMLHttpRequest, Object)</td>
            <td>undefined</td>
            <td class="refDescription">当AJAX请求成功完成的时候调用的自定义方法。 这个方法将被传入一个参数， 这个参数是承载AJAX操作的 <tt class="literal">XMLHttpRequest</tt> 对象，另一个是包含被执行X-JSON响应HTTP头。</td>
        </tr>
        <tr>
            <td>onFailure</td>
            <td>Function(XMLHttpRequest, Object)</td>
            <td>undefined</td>
            <td class="refDescription">当AJAX请求完成但出现错误的时候调用的自定义方法。这个方法将被传入一个参数， 这个参数是承载AJAX操作的 <tt class="literal">XMLHttpRequest</tt> 对象，另一个是包含被执行X-JSON响应HTTP头。</td>
        </tr>
        <tr>
            <td>onException</td>
            <td>Function(Ajax.Request, exception)</td>
            <td><nobr>undefined</nobr></td>
            <td class="refDescription">当一个在客户端执行的Ajax发生像无效响应或无效参数这样的异常情况时被调用的自定义函数。它收到两个参数，包含异常Ajax操作的Ajax.Request对象和异常对象。</td>
        </tr>
        <tr>
            <td>insertion</td>
            <td>an Insertion class</td>
            <td>undefined</td>
            <td class="refDescription">一个能决定怎么样插入新内容的类，能 <a class="code" href="#Insertion.Before">Insertion.Before</a>, <a class="code" href="#Insertion.Top">Insertion.Top</a>, <a class="code" href="#Insertion.Bottom">Insertion.Bottom</a>,&nbsp;或 <a class="code" href="#Insertion.After">Insertion.After</a>. 只能应用于<a class="code" href="#Ajax.Updater">Ajax.Updater</a> 对象. </td>
        </tr>
        <tr>
            <td>evalScripts</td>
            <td>Boolean</td>
            <td>undefined, false</td>
            <td class="refDescription">决定当响应到达的时候是否执行其中的脚本块，只在 <a title="4.16.&nbsp;Ajax.Updater 类" href="#ajax_updater_reference"><tt class="literal">Ajax.Updater</tt></a> 对象中应用。</td>
        </tr>
        <tr>
            <td>decay</td>
            <td>Number</td>
            <td>undefined, 1</td>
            <td class="refDescription">决定当最后一次响应和前一次响应相同时在 <a title="4.17.&nbsp;Ajax.PeriodicalUpdater 类" href="#ajax_periodical_updater"><tt class="literal">Ajax.PeriodicalUpdater</tt></a> 对象中的减漫访问的次数， 例如，如果设为2，后来的刷新和之前的结果一样， 这个对象将等待2个设定的时间间隔进行下一次刷新， 如果又一次一样， 那么将等待4次，等等。 不设定这个只，或者设置为1，将避免访问频率变慢。</td>
        </tr>
        <tr>
            <td>frequency</td>
            <td>Number</td>
            <td>undefined, 2</td>
            <td class="refDescription">用秒表示的刷新间的间隔，只能应用于 <a class="code" href="#Ajax.PeriodicalUpdater">Ajax.PeriodicalUpdater</a> &nbsp;对象。 </td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Ajax.Updater"></a></p>
<h4>The <span class="objectClass">Ajax.Updater</span> class</h4>
<p><em>继承自 <a class="code" href="#Ajax.Request">Ajax.Request</a></em></p>
<p>当请求的url返回一段HTML而你想把它直接放置到页面中一个特定的元素的时候被用到。 如果url的返回<tt class="literal">&lt;script&gt;</tt> 的块并且想在接收到时就执行它的时候也可以使用该对象。含有脚本的时候使用 <tt class="literal">evalScripts</tt> 选项。 </p>
<p>
<table class="reference" id="Table25" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Kind</th>
            <th>Description</th>
        </tr>
        <tr class="privateMember">
            <td>containers</td>
            <td>Object</td>
            <td>instance</td>
            <td class="refDescription">这个对象包含两个属性:AJAX请求成功执行的时候用到 <tt class="literal">containers.success</tt> , 否则的话用到 <tt class="literal">containers.failure</tt> 。</td>
        </tr>
    </tbody>
</table>
</p>
<p>
<table class="reference" id="Table26" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](container, url, options)</td>
            <td>constructor</td>
            <td>container:this can be the id of an element, the element object itself, or an object with two properties - <strong>object.success</strong> element (or id) that will be used when the AJAX call succeeds, and <strong>object.failure</strong> element (or id) that will be used otherwise. url: the url to be fetched, options: <a class="code" href="#Ajax.options">AJAX options</a></td>
            <td class="refDescription">创建一个用给定的选项请求给定的url的一个实例。</td>
        </tr>
        <tr class="privateMember">
            <td>updateContent()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">这个方法通常不会被外部调用。 当响应到达的时候，被这个对象自己调用。 它会用HTML更新适当的元素或者调用在 <tt class="literal">insertion</tt> 选项中传入的方法-这个方法将被传入两个参数， 被更新的元素和响应文本。 </td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Ajax.PeriodicalUpdater"></a></p>
<h4>The <span class="objectClass">Ajax.PeriodicalUpdater</span> class</h4>
<p><em><a class="code" href="#Ajax.Base">继承自Ajax.Base</a></em></p>
<p>这个类重复生成并使用 <tt class="literal">Ajax.Updater </tt>对象来刷新页面中的一个元素。或者执行 Ajax.Updater 可以执行的其它任务。更多信息参照 <a title="4.16.&nbsp;Ajax.Updater 类" href="#ajax_updater_reference">Ajax.Updater 参考</a> 。 </p>
<p>
<table class="reference" id="Table27" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Kind</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>container</td>
            <td>Object</td>
            <td><nobr>instance</nobr></td>
            <td class="refDescription">这个值将直接传入<tt class="literal">Ajax.Updater</tt>的构造方法。</td>
        </tr>
        <tr>
            <td>url</td>
            <td>String</td>
            <td>instance</td>
            <td class="refDescription">这个值将直接传入<tt class="literal">Ajax.Updater</tt>的构造方法。</td>
        </tr>
        <tr>
            <td>frequency</td>
            <td>Number</td>
            <td>instance</td>
            <td class="refDescription">两次刷新之间的间隔 (不是频率) ，以秒为单位。 默认2秒。 This 当调用 <tt class="literal">Ajax.Updater</tt> 对象的时候，这个数将和当前的 <tt class="literal">decay</tt> 相乘。 </td>
        </tr>
        <tr>
            <td>decay</td>
            <td><nobr>Number</nobr></td>
            <td>instance</td>
            <td class="refDescription">重负执行任务的时候保持的衰败水平。</td>
        </tr>
        <tr class="privateMember">
            <td>updater</td>
            <td><a href="#Ajax.Updater">Ajax.Updater</a></td>
            <td>instance</td>
            <td class="refDescription">最后一次使用的 <tt class="literal">Ajax.Updater </tt>对象</td>
        </tr>
        <tr class="privateMember">
            <td>timer</td>
            <td>Object</td>
            <td>instance</td>
            <td class="refDescription">通知对象该下一次更新时用到的JavaScript 计时器。</td>
        </tr>
    </tbody>
</table>
</p>
<p>
<table class="reference" id="Table28" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](container, url, options)</td>
            <td>constructor</td>
            <td>container:this can be the id of an element, the element object itself, or an object with two properties - <span class="code">object.success</span> element (or id) that will be used when the AJAX call succeeds, and <span class="code">object.failure</span> element (or id) that will be used otherwise. url: the url to be fetched, options: <a class="code" href="#Ajax.options">AJAX options</a></td>
            <td class="refDescription">创建一个用给定的选项请求给定的url的一个实例。</td>
        </tr>
        <tr class="privateMember">
            <td>start()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">这个方法通常不会被外部调用。 对象为了开始周期性执行任务的时候调用的方法。 </td>
        </tr>
        <tr>
            <td>stop()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">使对象停止执行周期任务。停止后，如果有onComplete选项，那么引发callback。 </td>
        </tr>
        <tr class="privateMember">
            <td>updateComplete()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">这个方法通常不会被外部调用。 被当前的 <tt class="literal">Ajax.Updater </tt>使用，当一次请求结束的时候，它被用作计划下一次请求。 </td>
        </tr>
        <tr class="privateMember">
            <td>onTimerEvent()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">这个方法通常不会被外部调用。当到下一次更新时被内部调用。 </td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Element"></a></p>
<h4>The <span class="objectClass">Element</span> object</h4>
<p>这个对象提供在操作DOM中元素时使用的功能性方法。</p>
<p>
<table class="reference" id="Table29" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>addClassName(element, className)</td>
            <td>instance</td>
            <td>element: element object or id, className: name of a CSS class</td>
            <td class="refDescription">将给出的className添加到对象的className属性中。</td>
        </tr>
        <tr>
            <td>classNames(element)</td>
            <td><nobr>instance</nobr></td>
            <td>element: element object or id</td>
            <td class="refDescription">返回一个Element.ClassName的对象表示CSS 给出对象有的class names。</td>
        </tr>
        <tr>
            <td>cleanWhitespace(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription">清除对象子元素中所有空白的text node。</td>
        </tr>
        <tr>
            <td>empty(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription">返回一个布尔值指示对象为空或只有空白字符。</td>
        </tr>
        <tr>
            <td>getDimensions(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription">返回对象的尺寸，返回值有两个属性，height和width。 </td>
        </tr>
        <tr>
            <td>getHeight(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription">返回元素的 <tt class="literal">offsetHeight</tt> 。</td>
        </tr>
        <tr>
            <td>getStyle(element, cssProperty)</td>
            <td>instance</td>
            <td>element: element object or id, cssProperty name of a CSS property (either format 'prop-name' or 'propName' works).</td>
            <td class="refDescription">返回给定对象的CSS属性值或没有指定cssProperty时返回null。</td>
        </tr>
        <tr>
            <td>hasClassName(element, className)</td>
            <td>instance</td>
            <td>element: element object or id, className: name of a CSS class</td>
            <td class="refDescription">返回 <tt class="literal">true</tt> 如果元素的类名中含有给定的类名</td>
        </tr>
        <tr>
            <td>hide(elem1 [, elem2 [, elem3 [...]]])</td>
            <td>instance</td>
            <td>elemN: element object or id</td>
            <td class="refDescription">通过设定<tt class="literal">style.display</tt> 为 <tt class="literal">'none'</tt>来隐藏每个传入的元素。 </td>
        </tr>
        <tr>
            <td>makeClipping(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription"><font face="宋体">能过设定overflow的值设定内容溢出剪辑。</font></td>
        </tr>
        <tr>
            <td>makePositioned(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription"><span class="code">更改对象的style.position为'relative'。</span></td>
        </tr>
        <tr>
            <td>remove(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription">从document对象中删除指定的元素。</td>
        </tr>
        <tr>
            <td>removeClassName(element, className)</td>
            <td>instance</td>
            <td>element: element object or id, className: name of a CSS class</td>
            <td class="refDescription">从元素的类名中删除给定的类名。</td>
        </tr>
        <tr>
            <td>scrollTo(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription">滚动window到对象的位置。</td>
        </tr>
        <tr>
            <td>setStyle(element, cssPropertyHash)</td>
            <td>instance</td>
            <td>element: element object or id, cssPropertyHash Hash object with the styles to be applied.</td>
            <td class="refDescription">依照cssPropertyHash参数给对象设置CSS属性值。</td>
        </tr>
        <tr>
            <td>show(elem1 [, elem2 [, elem3 [...]]])</td>
            <td>instance</td>
            <td>elemN: element object or id</td>
            <td class="refDescription">用设定它的 <tt class="literal">style.display </tt>为 <tt class="literal">''</tt>来显示每个传入的元素。 </td>
        </tr>
        <tr>
            <td>toggle(elem1 [, elem2 [, elem3 [...]]])</td>
            <td>instance</td>
            <td>elemN: element object or id</td>
            <td class="refDescription">切换每一个传入元素的可视性。</td>
        </tr>
        <tr>
            <td>undoClipping(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription"><font face="宋体">style.overflow的值返回上一个设定值。</font></td>
        </tr>
        <tr>
            <td>undoPositioned(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription">清除对象的 <span class="code">style.position</span> 为 <span class="code">''</span></td>
        </tr>
        <tr>
            <td>update(element, html)</td>
            <td>instance</td>
            <td>element: element object or id, html: html content</td>
            <td class="refDescription">用给出的HTML参数替换对象的innerHTML,如果HTML参数中包含&lt;script&gt;，那么它们不会被包含进去，但是会执行。 </td>
        </tr>
        <tr>
            <td>visible(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription">返回一个布尔值指示对象可不可见。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Element.ClassNames"></a></p>
<h4>The <span class="objectClass">Element.ClassNames</span> class</h4>
<p><em>继承自&nbsp; <a class="code" href="#Reference.Enumerable">Enumerable</a></em></p>
<p>在一个对象中表示CSS class names的集合。 </p>
<p>
<table class="reference" id="Table30" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](element)</td>
            <td>constructor</td>
            <td>element: any DOM element object or id</td>
            <td class="refDescription">创建一个对象，给出对象的CSS class names被表现在这个ClassNames对象中。 </td>
        </tr>
        <tr>
            <td>add(className)</td>
            <td><nobr>instance</nobr></td>
            <td>className: a CSS class name</td>
            <td class="refDescription">把CSS class name包含进对象的class names 列表。 </td>
        </tr>
        <tr>
            <td height="39">remove(className)</td>
            <td height="39">instance</td>
            <td height="39">className: a CSS class name</td>
            <td class="refDescription" height="39">从对象的class names列表中移除className </td>
        </tr>
        <tr>
            <td>set(className)</td>
            <td>instance</td>
            <td>className: a CSS class name</td>
            <td class="refDescription">设定对象CSS class name为className,移除其它class names。 </td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Abstract"></a></p>
<h4>The <span class="objectClass">Abstract</span> object</h4>
<p>这个对象是这个程序包中其他类的根。它没有任何属性和方法。在这个对象中定义的类可以被视为传统的抽象类。</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Abstract.Insertion"></a></p>
<h4>The <span class="objectClass">Abstract.Insertion</span> class</h4>
<p>这个类被用作其他提供动态内容插入功能的类的基类，它像一个抽象类一样被使用。</p>
<p>
<table class="reference" id="Table31" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](element, content)</td>
            <td>constructor</td>
            <td>element: element object or id, content: HTML to be inserted</td>
            <td class="refDescription">创建一个可以帮助插入动态内容的对象。</td>
        </tr>
        <tr class="privateMember">
            <td>contentFromAnonymousTable()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription"><font face="宋体">对content通过匿名表格变成一个Node数组。</font></td>
        </tr>
    </tbody>
</table>
</p>
<p>
<table class="reference" id="Table32" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Kind</th>
            <th>Description</th>
        </tr>
        <tr class="privateMember">
            <td>adjacency</td>
            <td>String</td>
            <td>static, parameter</td>
            <td class="refDescription">这个参数指定相对于给定元素，内容将被放置的位置。 可能的值是: <tt class="literal">'beforeBegin'</tt>, <tt class="literal">'afterBegin'</tt>, <tt class="literal">'beforeEnd'</tt>, 和 <tt class="literal">'afterEnd'</tt>.</td>
        </tr>
        <tr>
            <td>element</td>
            <td>Object</td>
            <td>instance</td>
            <td class="refDescription">与插入物做参照元素对象。</td>
        </tr>
        <tr>
            <td>content</td>
            <td>String</td>
            <td>instance</td>
            <td class="refDescription">被插入的 HTML 。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Insertion"></a></p>
<h4>The <span class="objectClass">Insertion</span> object</h4>
<p>这个对象是其他类似功能的根。它没有任何属性和方法。在这个对象中定义的类仍然可以被视为传统的抽象类。</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Insertion.Before"></a></p>
<h4>The <span class="objectClass">Insertion.Before</span> class</h4>
<p>继承自 <tt class="literal"><a title="4.20.&nbsp;Abstract.Insertion 类" href="#abstract_insertion">Abstract.Insertion</a></tt></p>
<p>在给定元素开始标记的前面插入HTML。</p>
<p>
<table class="reference" id="Table33" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](element, content)</td>
            <td><nobr>constructor</nobr></td>
            <td>element: element object or id, content: HTML to be inserted</td>
            <td class="refDescription">继承自&nbsp;&nbsp; <a class="code" href="#Abstract.Insertion">Abstract.Insertion</a>. 创建一个可以帮助插入动态内容的对象。</td>
        </tr>
    </tbody>
</table>
</p>
<pre class="code"><p>下面的代码</p>
&lt;br&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;
&lt;script&gt; <span class="highlite">new Insertion.Before('person', 'Chief ')</span>; &lt;/script&gt;
</pre>
<pre class="code"><p>将把 HTML 变为</p>
&lt;br&gt;Hello, <span class="highlite">Chief </span>&lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;
</pre>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Insertion.Top"></a></p>
<h4>The <span class="objectClass">Insertion.Top</span> class</h4>
<p>继承自 <tt class="literal"><a title="4.20.&nbsp;Abstract.Insertion 类" href="#abstract_insertion">Abstract.Insertion</a></tt></p>
<p>在给定元素第一个子节点位置插入 HTML。内容将位于元素的开始标记的紧后面。</p>
<p>
<table class="reference" id="Table34" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](element, content)</td>
            <td><nobr>constructor</nobr></td>
            <td>element: element object or id, content: HTML to be inserted</td>
            <td class="refDescription">继承自&nbsp;&nbsp;<a class="code" href="#Abstract.Insertion">Abstract.Insertion</a>. 创建一个可以帮助插入动态内容的对象。</td>
        </tr>
    </tbody>
</table>
</p>
<pre class="code"><p>下面的代码</p>
&lt;br&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;
&lt;script&gt; <span class="highlite">new Insertion.Top('person', 'Mr. ')</span>; &lt;/script&gt;
</pre>
<pre class="code"><p>将把 HTML 变为</p>
&lt;br&gt;Hello, &lt;span id="person" style="color:red;"&gt;<span class="highlite">Mr. </span>Wiggum. How's it going?&lt;/span&gt;
</pre>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Insertion.Bottom"></a></p>
<h4>The <span class="objectClass">Insertion.Bottom</span> class</h4>
<p><em>Inherits from <a class="code" href="#Abstract.Insertion">Abstract.Insertion</a></em></p>
<p>在给定元素最后一个子节点位置插入 HTML。内容将位于元素的结束标记的紧前面。</p>
<p>
<table class="reference" id="Table35" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](element, content)</td>
            <td>constructor</td>
            <td>element: element object or id, content: HTML to be inserted</td>
            <td class="refDescription">Inherited from <a class="code" href="#Abstract.Insertion">Abstract.Insertion</a>. Creates an object that will help with dynamic content insertion.</td>
        </tr>
    </tbody>
</table>
</p>
<p>The following code </p>
<pre class="code">&lt;br&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;
&lt;script&gt; <span class="highlite">new Insertion.Bottom('person', " What's up?")</span>; &lt;/script&gt;
</pre>
<p>Will change the HTML to </p>
<pre class="code">&lt;br&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?<span class="highlite"> What's up?</span>&lt;/span&gt;
</pre>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Insertion.After"></a></p>
<h4>The <span class="objectClass">Insertion.After</span> class</h4>
<p><em>Inherits from <a class="code" href="#Abstract.Insertion">Abstract.Insertion</a></em></p>
<p>在给定元素结束标记的后面插入HTML。</p>
<p>
<table class="reference" id="Table36" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](element, content)</td>
            <td>constructor</td>
            <td>element: element object or id, content: HTML to be inserted</td>
            <td class="refDescription">Inherited from <a class="code" href="#Abstract.Insertion">Abstract.Insertion</a>. Creates an object that will help with dynamic content insertion.</td>
        </tr>
    </tbody>
</table>
</p>
<p>The following code </p>
<pre class="code">&lt;br&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;
&lt;script&gt; <span class="highlite">new Insertion.After('person', ' Are you there?')</span>; &lt;/script&gt;
</pre>
<p>Will change the HTML to </p>
<pre class="code">&lt;br&gt;Hello, &lt;span id="person" style="color:red;"&gt;Wiggum. How's it going?&lt;/span&gt;<span class="highlite"> Are you there?</span>
</pre>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Field"></a></p>
<h4>The <span class="objectClass">Field</span> object</h4>
<p>这个对象提供操作表单中的输入项目的功能性方法。</p>
<p>
<table class="reference" id="Table37" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>clear(field1 [, field2 [, field3 [...]]])</td>
            <td>instance</td>
            <td>fieldN: field element object or id </td>
            <td class="refDescription">清除传入表单中项目元素的值。</td>
        </tr>
        <tr>
            <td>present(field1 [, field2 [, field3 [...]]])</td>
            <td>instance</td>
            <td>fieldN: field element object or id </td>
            <td class="refDescription">只有在所有的表单项目都不为空时返回 <tt class="literal">true</tt> 。</td>
        </tr>
        <tr>
            <td>focus(field)</td>
            <td><nobr>instance</nobr></td>
            <td>field: field element object or id</td>
            <td class="refDescription">移动焦点到给定的表单项目。</td>
        </tr>
        <tr>
            <td>select(field)</td>
            <td>instance</td>
            <td>field: field element object or id</td>
            <td class="refDescription">选择支持项目值选择的表单项目的值。</td>
        </tr>
        <tr>
            <td>activate(field)</td>
            <td>instance</td>
            <td>field: field element object or id</td>
            <td class="refDescription">移动焦点并且选择支持项目值选择的表单项目的值。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Form"></a></p>
<h4>The <span class="objectClass">Form</span> object</h4>
<p>这个对象提供操作表单和他们的输入元素的功能性方法。</p>
<p>
<table class="reference" id="Table38" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>serialize(form)</td>
            <td>instance</td>
            <td>form: form element object or id</td>
            <td class="refDescription">返回url参数格式的项目名和值的列表， 如<tt class="literal">'field1=value1&amp;field2=value2&amp;field3=value3'。</tt></td>
        </tr>
        <tr>
            <td>findFirstElement(form)</td>
            <td><nobr>instance</nobr></td>
            <td>form: form element object or id</td>
            <td class="refDescription">返回Form中第一个Enable的对象。</td>
        </tr>
        <tr>
            <td>getElements(form)</td>
            <td>instance</td>
            <td>form: form element object or id</td>
            <td class="refDescription">返回包含所有在表单中输入项目的 <tt class="literal">Array</tt> 对象。</td>
        </tr>
        <tr>
            <td>getInputs(form [, typeName [, name]])</td>
            <td>instance</td>
            <td>form: form element object or id, typeName: the type of the input element, name: the name of the input element.</td>
            <td class="refDescription">返回一个 <tt class="literal">Array</tt> 包含所有在表单中的 <tt class="literal">&lt;input&gt; 元素</tt>。 另外， 这个列表可以对元素的类型或名字属性进行过滤。</td>
        </tr>
        <tr>
            <td>disable(form)</td>
            <td>instance</td>
            <td>form: form element object or id</td>
            <td class="refDescription">使表单中的所有输入项目无效。</td>
        </tr>
        <tr>
            <td>enable(form)</td>
            <td>instance</td>
            <td>form: form element object or id</td>
            <td class="refDescription">使表单中的所有输入项目有效。</td>
        </tr>
        <tr>
            <td>focusFirstElement(form)</td>
            <td>instance</td>
            <td>form: form element object or id</td>
            <td class="refDescription">激活第一个表单中可视的，有效的输入项目。</td>
        </tr>
        <tr>
            <td>reset(form)</td>
            <td>instance</td>
            <td>form: form element object or id</td>
            <td class="refDescription">重置表单。和调用表单对象的 <tt class="literal">reset()</tt> 方法一样。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Form.Element"></a></p>
<h4>The <span class="objectClass">Form.Element</span> object</h4>
<p>这个对象提供表单对象中的可视和非可视元素的功能性方法。</p>
<p>
<table class="reference" id="Table39" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>serialize(element)</td>
            <td><nobr>instance</nobr></td>
            <td>element: element object or id</td>
            <td class="refDescription">返回元素的 名称=值 对, 如 <tt class="literal">'elementName=elementValue'。</tt></td>
        </tr>
        <tr>
            <td>getValue(element)</td>
            <td>instance</td>
            <td>element: element object or id</td>
            <td class="refDescription">返回元素的值。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Form.Element.Serializers"></a></p>
<h4>The <span class="objectClass">Form.Element.Serializers</span> object</h4>
<p>这个对象提供了内部使用的用来协助解析出表单元素的当前值的一些有用的方法。</p>
<p>
<table class="reference" id="Table40" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>inputSelector(element)</td>
            <td>instance</td>
            <td>element: object or id of a form element that has the <em>checked</em> property, like a radio button or checkbox.</td>
            <td class="refDescription">返回带有元素名称和值的 <tt class="literal">Array</tt> , 如 <tt class="literal">['elementName', 'elementValue']</tt></td>
        </tr>
        <tr>
            <td>textarea(element)</td>
            <td><nobr>instance</nobr></td>
            <td>element: object or id of a form element that has the <em>value</em> property, like a textbox, button or password field.</td>
            <td class="refDescription">返回带有元素名称和值的 <tt class="literal">Array</tt> , 如 <tt class="literal">['elementName', 'elementValue']</tt></td>
        </tr>
        <tr>
            <td>select(element)</td>
            <td>instance</td>
            <td>element: object of a &lt;select&gt; element</td>
            <td class="refDescription">返回带有元素名称和所有被选择的选项的值或文本的 <tt class="literal">Array</tt> , 如 <tt class="literal">['elementName', 'selOpt1 selOpt4 selOpt9']</tt></td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Abstract.TimedObserver"></a></p>
<h4>The <span class="objectClass">Abstract.TimedObserver</span> class</h4>
<p>这个类是用于其它监听一个元素的值(或者任何类中涉及的属性)变化的类的基类，这个类像一个抽象类一样被使用。</p>
<p>子类可以被创建来监听如输入项目值，或style属性，或表格的行数，或者其他任何对跟踪变化相关的东西。</p>
<p>子类必须实现这个方法来决定什么才是被监听的元素的当前值。
<table class="reference" id="Table41" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](element, frequency, callback)</td>
            <td>constructor</td>
            <td>element: element object or id, frequency: interval in seconds, callback: function to be called when the element changes</td>
            <td class="refDescription">创建一个监听元素的对象。</td>
        </tr>
        <tr class="privateMember">
            <td>getValue()</td>
            <td>instance, abstract</td>
            <td>(none)</td>
            <td class="refDescription">子类必须实现这个方法以瘊定什么这个元素被监视的当前值。</td>
        </tr>
        <tr class="privateMember">
            <td>registerCallback()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">这个方法通常不会被外部调用。 被这个对象自己调用来开始监听那个元素。 </td>
        </tr>
        <tr class="privateMember">
            <td>onTimerEvent()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">这个方法通常不会被外部调用。 被这个对象自己调用来周期性的检查那个元素。 </td>
        </tr>
    </tbody>
</table>
</p><p>
<table class="reference" id="Table42" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>element</td>
            <td>Object</td>
            <td class="refDescription">被监听的元素对象。</td>
        </tr>
        <tr>
            <td>frequency</td>
            <td><nobr>Number</nobr></td>
            <td class="refDescription">每次检查中的以秒为单位的时间间隔。</td>
        </tr>
        <tr>
            <td>callback</td>
            <td>Function(Object, String)</td>
            <td class="refDescription">只要元素改变这个方法就会被调用。 会接收到元素对象和新值作为参数。</td>
        </tr>
        <tr class="privateMember">
            <td>lastValue</td>
            <td>String</td>
            <td class="refDescription">元素被核实的最后一个值。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Form.Element.Observer"></a></p>
<h4>The <span class="objectClass">Form.Element.Observer</span> class</h4>
<p>继承自 <tt class="literal"><a title="4.30.&nbsp;Abstract.TimedObserver 类" href="#abstract_timed_observer">Abstract.TimedObserver</a></tt></p>
<p><tt class="literal">Abstract.TimedObserver</tt> 的一个实现类用来监听表单输入项目的值的变化。当你想监听一个没有带报告值变化事件的元素的时候使用这个类。否则的话使用 <tt class="literal"><a title="4.34.&nbsp;Form.Element.EventObserver 类" href="#form_element_event_observer">Form.Element.EventObserver</a></tt> 类代替。</p>
<p>
<table class="reference" id="Table43" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](element, frequency, callback)</td>
            <td>constructor</td>
            <td>element: element object or id, frequency: interval in seconds, callback: function to be called when the element changes</td>
            <td class="refDescription">继承自 <tt class="literal">Abstract.TimedObserver</tt>. 创建一个监听元素值属性的对象。</td>
        </tr>
        <tr class="privateMember">
            <td>getValue()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">返回元素的值。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Form.Observer"></a></p>
<h4>The <span class="objectClass">Form.Observer</span> class</h4>
<p>继承自 <tt class="literal"><a title="4.30.&nbsp;Abstract.TimedObserver 类" href="#abstract_timed_observer">Abstract.TimedObserver</a></tt></p>
<p><tt class="literal">Abstract.TimedObserver</tt> 的一个实现类用来监听表单中任何数据项的值的变化。当你想监听一个没有带报告值变化事件的元素的时候使用这个类。 否则的话使用类<tt class="literal"><a title="4.35.&nbsp;Form.EventObserver 类" href="#form_event_observer">Form.EventObserver</a></tt> 代替。</p>
<p>
<table class="reference" id="Table44" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](form, frequency, callback)</td>
            <td>constructor</td>
            <td>form:
form object or id, frequency: interval in seconds, callback function to
be called when any data entry element in the form changes</td>
            <td class="refDescription">继承自 <tt class="literal">Abstract.TimedObserver</tt>. 创建一个监听表单变化的对象。</td>
        </tr>
        <tr class="privateMember">
            <td>getValue()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">返回所有表单数据的一系列值。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Abstract.EventObserver"></a></p>
<h4>The <span class="objectClass">Abstract.EventObserver</span> class</h4>
<p>这个类被用作其他一些类的基类，这些类具有在一个元素的值改变事件发生的时候执行一个回调方法这样的功能。</p>
<p>类 <tt class="literal">Abstract.EventObserver 的多个对象可以绑定到一个元素上，不是一个帮其他的擦出了，而是按照他们付给元素的顺序执行这些回调方法。</tt></p>
<p>单选按钮和复选框的触发事件是 <tt class="literal">onclick</tt> ，而文本框和下拉列表框/下拉列表框的是 <tt class="literal">onchange</tt> 。&nbsp;
</p><p>
<table class="reference" id="Table45" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](element, callback)</td>
            <td>constructor</td>
            <td>element: element object or id, callback: function to be called when the event happens</td>
            <td class="refDescription">创建监听元素的对象。</td>
        </tr>
        <tr class="privateMember">
            <td>getValue()</td>
            <td><nobr>instance,abstract</nobr></td>
            <td>(none)</td>
            <td class="refDescription">子类必须实现这个方法以瘊定什么这个元素被监视的当前值。</td>
        </tr>
        <tr class="privateMember">
            <td>registerCallback()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">这个方法通常不会被外部调用。 被对象调用来把自己绑定到元素的事件上。 </td>
        </tr>
        <tr class="privateMember">
            <td>registerFormCallbacks()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">这个方法通常不会被外部调用。 被对象调用来把自己绑定到表单中的每一个数据项元素的事件上。 </td>
        </tr>
        <tr class="privateMember">
            <td>onElementEvent()</td>
            <td>instance</td>
            <td>(none)</td>
            <td class="refDescription">这个方法通常不会被外部调用。 将被绑定到元素的事件上。 </td>
        </tr>
    </tbody>
</table>
</p>
<p>
<table class="reference" id="Table46" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Property</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>element</td>
            <td>Object</td>
            <td class="refDescription">被监听的元素对象。</td>
        </tr>
        <tr>
            <td>callback</td>
            <td>Function(Object, String)</td>
            <td class="refDescription">只要元素改变就调用的方法。会接收到元素对象和新值作为参数。</td>
        </tr>
        <tr class="privateMember">
            <td>lastValue</td>
            <td>String</td>
            <td class="refDescription">元素被核实的最后一个值。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Form.Element.EventObserver"></a></p>
<h4>The <span class="objectClass">Form.Element.EventObserver</span> class</h4>
<p>继承自 <a title="4.33.&nbsp;Abstract.EventObserver 类" href="#abstract_event_observer"><tt class="literal">Abstract.EventObserver</tt></a></p>
<p><tt class="literal">Abstract.EventObserver</tt> 的一个实现类，它在监测到表单中数据项元素的值改变的相应事件时候执行一个回调方法。 如果元素没有任何报告变化的事件，那么你可以使用 <tt class="literal"><a title="4.31.&nbsp;Form.Element.Observer 类" href="#form_element_observer">Form.Element.Observer</a></tt> 类代替。</p>
<p>
<table class="reference" id="Table47" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](element, callback)</td>
            <td>constructor</td>
            <td>element: element object or id, callback: function to be called when the event happens</td>
            <td class="refDescription">继承自 <tt class="literal">Abstract.EventObserver</tt>。 创建一个监听元素值属性的对象。</td>
        </tr>
        <tr class="privateMember">
            <td>getValue()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">返回元素的值。</td>
        </tr>
    </tbody>
</table>
</p>
<p><!-- ------------------------------------------------------------------------------------------- --><a name="Form.Observer"></a></p>
<h4>The <span class="objectClass">Form.EventObserver</span> class</h4>
<p>继承自 <a title="4.33.&nbsp;Abstract.EventObserver 类" href="#abstract_event_observer"><tt class="literal">Abstract.EventObserver</tt></a></p>
<p><tt class="literal">Abstract.EventObserver</tt> 的一个实现类，监听表单对象中包含的任何对象的任何变化，用元素的事件检测值的变化。如果元素没有任何报告变化的事件， 那么你可以使用<tt class="literal"><a title="4.32.&nbsp;Form.Observer 类" href="#form_observer">Form.Observer</a></tt> 类代替。
<table class="reference" id="Table48" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>[ctor](form, callback)</td>
            <td>constructor</td>
            <td>form: form object or id, callback: function to be called when any data entry element in the form changes</td>
            <td class="refDescription">继承自 <tt class="literal">Abstract.EventObserver</tt>。 创建一个监听元素值属性的对象。</td>
        </tr>
        <tr class="privateMember">
            <td>getValue()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">返回所有表单数据的一系列值。</td>
        </tr>
    </tbody>
</table>
</p><p><a name="Position"></a></p>
<h3 class="title"><a name="d0e3420"></a><tt class="literal">Position</tt> 对象 (预备文档)</h3>
<p>这个对象提供许多和元素位置相关的方法。</p>
<p>
<table class="reference" id="Table49" border="1" cellspacing="0">
    <tbody>
        <tr>
            <th>Method</th>
            <th>Kind</th>
            <th>Arguments</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>prepare()</td>
            <td><nobr>instance</nobr></td>
            <td>(none)</td>
            <td class="refDescription">调整 <tt class="literal">deltaX</tt> 和 <tt class="literal">deltaY</tt> 属性来协调在滚动位置中的变化。 记得在页面滚动之后的任何调用的<tt class="literal">withinIncludingScrolloffset</tt> 之前调用这个方法。</td>
        </tr>
        <tr>
            <td>realOffset(element)</td>
            <td><nobr>instance</nobr></td>
            <td>element: object</td>
            <td class="refDescription">返回这个元素的正确滚动偏差的 <tt class="literal">Array</tt> 对象， 包括所有影响元素的滚动偏差。结果数组类似 <tt class="literal">[total_scroll_left, total_scroll_top]</tt></td>
        </tr>
        <tr>
            <td>cumulativeOffset(element)</td>
            <td>instance</td>
            <td>element: object</td>
            <td class="refDescription">回这个元素的正确滚动偏差的 <tt class="literal">Array</tt> 对象， 包含任何被放置的父元素强加偏差。结果数组类似 <tt class="literal">[total_offset_left, total_offset_top]</tt></td>
        </tr>
        <tr>
            <td>within(element, x, y)</td>
            <td>instance</td>
            <td>element: object, x and y: coordinates of a point</td>
            <td class="refDescription">测试给定的点的坐标是否在给定的元素的外部矩形范围之内。</td>
        </tr>
        <tr>
            <td>withinIncludingScrolloffsets(element, x, y)</td>
            <td>instance</td>
            <td>element: object, x and y: coordinates of a point</td>
            <td class="refDescription">&nbsp;测试给定的点的坐标是否在给定的元素的外部矩形范围之内（包含scroll offsets）。</td>
        </tr>
        <tr>
            <td>overlap(mode, element)</td>
            <td><nobr>instance</nobr></td>
            <td>mode: 'vertical' or 'horizontal', element: object</td>
            <td class="refDescription">在调用这个方法之前需要调用<tt class="literal">within()</tt> 。这个方法返回0.0到1.0之间的数字，来表示坐标在元素重叠的分数。 举个例子，如果元素是一个边长是100px的正方形的DIV，并且位于(300, 300), 然后 <tt class="literal">within(divSquare, 330, 330)；</tt><tt class="literal">overlap('vertical', divSquare); </tt>会返回 0.10，意思是那个点位于DIV顶部边框以下 10% (30px) 的位置上。 </td>
        </tr>
        <tr>
            <td>clone(source, target)</td>
            <td>instance</td>
            <td>source: element object or id, target: element object or id</td>
            <td class="refDescription">改变目标元素的大小尺寸和位置与源元素的相同。</td>
        </tr>
    </tbody>
</table>
</p>
</div>
<div></div>
<div></div> 
		</div>
		<p class="postfoot">
			posted on 2006-04-01 18:38 <a href="http://thinhunan.cnblogs.com/">THIN</a> 阅读(90799) <a href="#Post">评论(123)</a> &nbsp;<a href="http://www.cnblogs.com/thinhunan/admin/EditPosts.aspx?postid=364404">编辑</a> &nbsp;<a id="lnkFavorite364404" href="#" onclick="Favorite(364404,'prototype.js　1.4版开发者手册(强烈推荐) ','http://www.cnblogs.com/thinhunan/archive/2006/04/01/DeveloperNotesForPrototype.html',this);return false">收藏</a>  所属分类: <a href="http://www.cnblogs.com/thinhunan/category/22345.html">DHTML &amp; Javascript</a> 
		</p>
	</div>
	<img src="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/364404.jpg" height="1" width="1">
	
<!--
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/">
<rdf:Description
rdf:about="http://www.cnblogs.com/thinhunan/archive/2006/04/01/DeveloperNotesForPrototype.html"
dc:identifier="http://www.cnblogs.com/thinhunan/archive/2006/04/01/DeveloperNotesForPrototype.html"
dc:title="prototype.js　1.4版开发者手册(强烈推荐) "
trackback:ping="http://www.cnblogs.com/thinhunan/services/trackbacks/364404.aspx" />
</rdf:RDF>
-->

	
<div id="AjaxHolder_UpdatePanel1">  </div>
</div>
		</td>
	</tr>
	<tr>
		<td class="FooterCell">
			
<p id="footer">
	Powered by: 
	<br>
	
	<a id="Footer1_Hyperlink3" name="Hyperlink1" href="http://www.cnblogs.com/" style="font-family: Verdana; font-size: 12px;">博客园</a>
	<br>
	Copyright © THIN
</p>
		</td>
	</tr>
</tbody></table>
<div id="lefttemp" style="display: none;"></div>
<script type="text/javascript">
function moveNav(){
    var leftmenu = document.getElementById("leftmenu");
    var h3 = leftmenu.getElementsByTagName("H3")[0];
    if(!h3){
        setTimeout(moveNav,10);
        return;
    }
    var ul = leftmenu.getElementsByTagName("UL")[0];
    ul.style.margin = "0";
    ul.style.padding = "0";
    var sub = document.getElementById("sub");
    h3.style.styleFloat = "left";
    h3.style.display = "none";    
    ul.style.styleFloat = "left";
    var lis = ul.getElementsByTagName("LI");
    for(var i = 0 ; i < lis.length; i++){
         lis[i].style.styleFloat = "left";   
         lis[i].style.padding= "0 4px";   
    }
    var anchors = ul.getElementsByTagName("A");
    for(var i = 0 ; i < anchors.length ; i++){
        anchors[i].style.color="#ccc";
    }
    sub.firstChild.style.styleFloat = "right";
    sub.appendChild(ul);  
    sub.style.height = "2em"; 
}
moveNav();
</script>
    
<script type="text/javascript">
<!--
var Page_ValidationSummaries =  new Array(document.getElementById("AjaxHolder_PostComment_ValidationSummary1"));
var Page_Validators =  new Array(document.getElementById("AjaxHolder_PostComment_RequiredFieldValidator1"), document.getElementById("AjaxHolder_PostComment_RequiredFieldValidator2"), document.getElementById("AjaxHolder_PostComment_revContactMail"), document.getElementById("AjaxHolder_PostComment_Requiredfieldvalidator4"), document.getElementById("AjaxHolder_PostComment_RequiredFieldValidator3"));
// -->
</script>

<script type="text/javascript">
<!--
var AjaxHolder_PostComment_RequiredFieldValidator1 = document.all ? document.all["AjaxHolder_PostComment_RequiredFieldValidator1"] : document.getElementById("AjaxHolder_PostComment_RequiredFieldValidator1");
AjaxHolder_PostComment_RequiredFieldValidator1.controltovalidate = "AjaxHolder_PostComment_tbTitle";
AjaxHolder_PostComment_RequiredFieldValidator1.errormessage = "请输入标题";
AjaxHolder_PostComment_RequiredFieldValidator1.evaluationfunction = "RequiredFieldValidatorEvaluateIsValid";
AjaxHolder_PostComment_RequiredFieldValidator1.initialvalue = "";
var AjaxHolder_PostComment_RequiredFieldValidator2 = document.all ? document.all["AjaxHolder_PostComment_RequiredFieldValidator2"] : document.getElementById("AjaxHolder_PostComment_RequiredFieldValidator2");
AjaxHolder_PostComment_RequiredFieldValidator2.controltovalidate = "AjaxHolder_PostComment_tbName";
AjaxHolder_PostComment_RequiredFieldValidator2.errormessage = "请输入你的姓名";
AjaxHolder_PostComment_RequiredFieldValidator2.evaluationfunction = "RequiredFieldValidatorEvaluateIsValid";
AjaxHolder_PostComment_RequiredFieldValidator2.initialvalue = "";
var AjaxHolder_PostComment_revContactMail = document.all ? document.all["AjaxHolder_PostComment_revContactMail"] : document.getElementById("AjaxHolder_PostComment_revContactMail");
AjaxHolder_PostComment_revContactMail.controltovalidate = "AjaxHolder_PostComment_tbEmail";
AjaxHolder_PostComment_revContactMail.errormessage = "邮件地址无效";
AjaxHolder_PostComment_revContactMail.evaluationfunction = "RegularExpressionValidatorEvaluateIsValid";
AjaxHolder_PostComment_revContactMail.validationexpression = "^([0-9a-zA-Z+-._]([+-._\\w]*[0-9a-zA-Z+-._])*@([0-9a-zA-Z][-\\w]*\\.)+[a-zA-Z]{2,9})$";
var AjaxHolder_PostComment_Requiredfieldvalidator4 = document.all ? document.all["AjaxHolder_PostComment_Requiredfieldvalidator4"] : document.getElementById("AjaxHolder_PostComment_Requiredfieldvalidator4");
AjaxHolder_PostComment_Requiredfieldvalidator4.controltovalidate = "AjaxHolder_PostComment_CodeNumberTextBox";
AjaxHolder_PostComment_Requiredfieldvalidator4.errormessage = "请输入验证码";
AjaxHolder_PostComment_Requiredfieldvalidator4.display = "Dynamic";
AjaxHolder_PostComment_Requiredfieldvalidator4.evaluationfunction = "RequiredFieldValidatorEvaluateIsValid";
AjaxHolder_PostComment_Requiredfieldvalidator4.initialvalue = "";
var AjaxHolder_PostComment_RequiredFieldValidator3 = document.all ? document.all["AjaxHolder_PostComment_RequiredFieldValidator3"] : document.getElementById("AjaxHolder_PostComment_RequiredFieldValidator3");
AjaxHolder_PostComment_RequiredFieldValidator3.controltovalidate = "AjaxHolder_PostComment_tbComment";
AjaxHolder_PostComment_RequiredFieldValidator3.errormessage = "请输入评论内容";
AjaxHolder_PostComment_RequiredFieldValidator3.evaluationfunction = "RequiredFieldValidatorEvaluateIsValid";
AjaxHolder_PostComment_RequiredFieldValidator3.initialvalue = "";
var AjaxHolder_PostComment_ValidationSummary1 = document.all ? document.all["AjaxHolder_PostComment_ValidationSummary1"] : document.getElementById("AjaxHolder_PostComment_ValidationSummary1");
AjaxHolder_PostComment_ValidationSummary1.showmessagebox = "True";
AjaxHolder_PostComment_ValidationSummary1.showsummary = "False";
// -->
</script>


<script type="text/javascript">
<!--
var Page_ValidationActive = false;
if (typeof(ValidatorOnLoad) == "function") {
    ValidatorOnLoad();
}

function ValidatorOnSubmit() {
    if (Page_ValidationActive) {
        return ValidatorCommonOnSubmit();
    }
    else {
        return true;
    }
}
// -->
</script>
        
<script type="text/javascript">
<!--

document.getElementById('AjaxHolder_PostComment_ValidationSummary1').dispose = function() {
    Array.remove(Page_ValidationSummaries, document.getElementById('AjaxHolder_PostComment_ValidationSummary1'));
}
Sys.Application.initialize();

document.getElementById('AjaxHolder_PostComment_RequiredFieldValidator1').dispose = function() {
    Array.remove(Page_Validators, document.getElementById('AjaxHolder_PostComment_RequiredFieldValidator1'));
}

document.getElementById('AjaxHolder_PostComment_RequiredFieldValidator2').dispose = function() {
    Array.remove(Page_Validators, document.getElementById('AjaxHolder_PostComment_RequiredFieldValidator2'));
}

document.getElementById('AjaxHolder_PostComment_revContactMail').dispose = function() {
    Array.remove(Page_Validators, document.getElementById('AjaxHolder_PostComment_revContactMail'));
}

document.getElementById('AjaxHolder_PostComment_Requiredfieldvalidator4').dispose = function() {
    Array.remove(Page_Validators, document.getElementById('AjaxHolder_PostComment_Requiredfieldvalidator4'));
}

document.getElementById('AjaxHolder_PostComment_RequiredFieldValidator3').dispose = function() {
    Array.remove(Page_Validators, document.getElementById('AjaxHolder_PostComment_RequiredFieldValidator3'));
}
// -->
</script>
</form>
    <script type="text/javascript" src="prototype.js%A1%A11.4%B0%E6%BF%AA%B7%A2%D5%DF%CA%D6%B2%E1%28%C7%BF%C1%D2%CD%C6%BC%F6%29_files/ShowHidden.js"></script>      
</body></html>